<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Complex Quiz - SkillOns</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- MathJax for complex mathematical expressions -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Quill.js for rich text editing -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

    <!-- PDF Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        :root {
            --primary-color: #4f46e5;
            --secondary-color: #7c3aed;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --dark-color: #1e293b;
            --light-color: #f8fafc;
            --border-color: #e2e8f0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--light-color);
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        .quiz-builder-container {
            display: flex;
            height: 100vh;
            background: var(--light-color);
        }

        /* Sidebar with tools */
        .tools-sidebar {
            width: 280px;
            background: white;
            border-right: 2px solid var(--border-color);
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.05);
            overflow-y: auto;
            z-index: 100;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .sidebar-header h4 {
            margin: 0;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .tool-category {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .tool-category h6 {
            margin: 0 0 15px 0;
            font-weight: 600;
            color: var(--dark-color);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            margin: 5px 0;
            background: var(--light-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: grab;
            transition: all 0.3s ease;
            user-select: none;
        }

        .tool-item:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        .tool-item:active {
            cursor: grabbing;
        }

        .tool-item i {
            margin-right: 10px;
            font-size: 1.1rem;
            width: 20px;
            text-align: center;
        }

        .tool-item span {
            font-weight: 500;
            font-size: 0.9rem;
        }

        /* Main canvas area */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fafbfc;
        }

        /* PDF Equation Rendering Styles */
        .pdf-equation-container .MathJax {
            font-size: 120% !important;
            line-height: 1.8 !important;
            margin: 10px 0 !important;
        }

        .pdf-equation-container .MathJax_Display {
            margin: 20px 0 !important;
            padding: 10px !important;
        }

        .pdf-equation-container mjx-container {
            margin: 15px 0 !important;
            padding: 8px !important;
            overflow: visible !important;
        }

        .pdf-equation-container mjx-math {
            font-size: 1.2em !important;
            line-height: 1.6 !important;
        }

        /* PDF Equation Rendering Styles */
        .pdf-equation-container .MathJax {
            font-size: 120% !important;
            line-height: 1.8 !important;
            margin: 10px 0 !important;
        }

        .pdf-equation-container .MathJax_Display {
            margin: 20px 0 !important;
            padding: 10px !important;
        }

        .pdf-equation-container mjx-container {
            margin: 15px 0 !important;
            padding: 8px !important;
            overflow: visible !important;
        }

        .pdf-equation-container mjx-math {
            font-size: 1.2em !important;
            line-height: 1.6 !important;
        }

        .canvas-header {
            background: white;
            padding: 15px 25px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .canvas-title {
            font-weight: 600;
            color: var(--dark-color);
            margin: 0;
        }

        .canvas-actions {
            display: flex;
            gap: 10px;
        }

        .btn-canvas {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary-canvas {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary-canvas:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
        }

        .btn-secondary-canvas {
            background: var(--border-color);
            color: var(--dark-color);
        }

        .btn-secondary-canvas:hover {
            background: #cbd5e1;
        }

        .btn-info-canvas {
            background: #17a2b8;
            color: white;
        }

        .btn-info-canvas:hover {
            background: #138496;
            transform: translateY(-1px);
        }

        .btn-warning-canvas {
            background: #f59e0b;
            color: white;
        }

        .btn-warning-canvas:hover {
            background: #d97706;
            transform: translateY(-1px);
        }

        .btn-navigation-canvas {
            background: #6366f1;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 40px;
        }

        .btn-navigation-canvas:hover:not(:disabled) {
            background: #4f46e5;
            transform: translateY(-1px);
        }

        .btn-navigation-canvas:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .question-counter {
            background: #f3f4f6;
            color: #374151;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            margin: 0 5px;
            min-width: 50px;
            text-align: center;
            border: 2px solid #e5e7eb;
        }

        .btn-group {
            display: flex;
            align-items: center;
            gap: 0;
        }

        .btn-group .btn-navigation-canvas:first-child {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .btn-group .btn-navigation-canvas:last-child {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        /* Canvas workspace */
        .canvas-workspace {
            flex: 1;
            padding: 20px;
            overflow: auto;
            position: relative;
        }

        .canvas-area {
            min-height: 800px;
            background: white;
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            position: relative;
            margin: 0 auto;
            max-width: 1000px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            /* Ensure canvas can receive drop events */
            pointer-events: all;
            z-index: 1;
        }

        .canvas-area.drag-over {
            border-color: var(--primary-color);
            background: rgba(79, 70, 229, 0.05);
            border-style: solid;
            transform: scale(1.01);
            transition: all 0.3s ease;
        }

        .canvas-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #94a3b8;
            pointer-events: all;
            cursor: pointer;
            padding: 40px;
            border-radius: 12px;
            transition: all 0.3s ease;
            user-select: none;
        }

        .canvas-placeholder:hover {
            color: var(--primary-color);
            background: rgba(79, 70, 229, 0.05);
        }

        .canvas-placeholder i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .canvas-placeholder h5 {
            margin: 0 0 10px 0;
            font-weight: 600;
        }

        .canvas-placeholder p {
            margin: 0;
            font-size: 0.9rem;
        }

        /* Properties panel */
        .properties-panel {
            width: 320px;
            background: white;
            border-left: 2px solid var(--border-color);
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05);
            overflow-y: auto;
            z-index: 100;
        }

        .properties-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, var(--success-color), #059669);
            color: white;
        }

        .properties-header h5 {
            margin: 0;
            font-weight: 600;
        }

        .properties-content {
            padding: 20px;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--dark-color);
            font-size: 0.9rem;
        }

        .property-group input,
        .property-group select,
        .property-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .property-group input:focus,
        .property-group select:focus,
        .property-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        /* Draggable elements */
        .canvas-element {
            position: absolute;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: move;
            transition: all 0.3s ease;
            min-width: 100px;
            min-height: 50px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .canvas-element:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }

        .canvas-element.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
        }

        .canvas-element.current-question {
            border-color: #10b981 !important;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3);
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse-green {
            0% {
                box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3);
            }
            50% {
                box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.2);
            }
            100% {
                box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3);
            }
        }

        .element-controls {
            position: absolute;
            top: -30px;
            right: 0;
            display: none;
            gap: 5px;
        }

        .canvas-element:hover .element-controls,
        .canvas-element.selected .element-controls {
            display: flex;
        }

        .control-btn {
            width: 24px;
            height: 24px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }

        .control-btn:hover {
            background: var(--secondary-color);
        }

        .control-btn.delete {
            background: var(--danger-color);
        }

        /* Shape-specific tool styling */
        .tool-item[data-type="line"] i {
            color: #ef4444;
        }
        .tool-item[data-type="triangle"] i {
            color: #f59e0b;
        }
        .tool-item[data-type="square"] i {
            color: #10b981;
        }
        .tool-item[data-type="rectangle"] i {
            color: #059669;
        }
        .tool-item[data-type="rhombus"] i {
            color: #dc2626;
        }
        .tool-item[data-type="circle"] i {
            color: #3b82f6;
        }
        .tool-item[data-type="parallelogram"] i {
            color: #8b5cf6;
        }
        .tool-item[data-type="pentagon"] i {
            color: #ec4899;
        }
        .tool-item[data-type="hexagon"] i {
            color: #06b6d4;
        }
        .tool-item[data-type="cube"] i {
            color: #6366f1;
        }
        .tool-item[data-type="sphere"] i {
            color: #84cc16;
        }
        .tool-item[data-type="cuboid"] i {
            color: #f97316;
        }

        /* Shape preview in canvas */
        .canvas-element svg {
            border-radius: 6px;
        }

        /* Enhanced tool category headers */
        .tool-category h6 {
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e5e7eb;
        }

        /* Math Category Styles */
        .math-category-header:hover {
            background: #f3f4f6;
            border-radius: 6px;
            padding: 8px !important;
        }

        .math-subcategory {
            margin-bottom: 16px;
            padding-left: 8px;
            border-left: 2px solid #e5e7eb;
        }

        .math-subcategory-title {
            color: #6b7280;
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .math-subcategory .tool-item {
            margin-bottom: 6px;
            font-size: 13px;
            padding: 8px 12px;
        }

        .math-subcategory .tool-item i {
            width: 16px;
            font-size: 12px;
        }

        #math-chevron.rotated {
            transform: rotate(180deg);
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .tools-sidebar {
                width: 250px;
            }
            
            .properties-panel {
                width: 280px;
            }
        }

        @media (max-width: 768px) {
            .quiz-builder-container {
                flex-direction: column;
            }
            
            .tools-sidebar,
            .properties-panel {
                width: 100%;
                height: auto;
                max-height: 200px;
            }
            
            .canvas-container {
                height: calc(100vh - 400px);
            }
        }
    </style>
</head>
<body>
    <div class="quiz-builder-container">
        <!-- Tools Sidebar -->
        <div class="tools-sidebar">
            <div class="sidebar-header">
                <h4><i class="fas fa-tools me-2"></i>Quiz Builder Tools</h4>
            </div>
            
            <!-- Basic Elements -->
            <div class="tool-category">
                <h6>Basic Elements</h6>
                <div class="tool-item" draggable="true" data-type="textbox">
                    <i class="fas fa-font"></i>
                    <span>Text Box</span>
                </div>
                <div class="tool-item" draggable="true" data-type="image">
                    <i class="fas fa-image"></i>
                    <span>Image</span>
                </div>
                <div class="tool-item" draggable="true" data-type="table">
                    <i class="fas fa-table"></i>
                    <span>Table</span>
                </div>
            </div>
            
            <!-- Geometric Shapes -->
            <div class="tool-category">
                <h6><i class="fas fa-shapes me-2"></i>Geometric Shapes</h6>
                <div class="tool-item" draggable="true" data-type="line">
                    <i class="fas fa-minus"></i>
                    <span>Line</span>
                </div>
                <div class="tool-item" draggable="true" data-type="triangle">
                    <i class="fas fa-play" style="transform: rotate(90deg);"></i>
                    <span>Triangle</span>
                </div>
                <div class="tool-item" draggable="true" data-type="square">
                    <i class="fas fa-square"></i>
                    <span>Square</span>
                </div>
                <div class="tool-item" draggable="true" data-type="rectangle">
                    <i class="far fa-square"></i>
                    <span>Rectangle</span>
                </div>
                <div class="tool-item" draggable="true" data-type="rhombus">
                    <i class="fas fa-gem"></i>
                    <span>Rhombus</span>
                </div>
                <div class="tool-item" draggable="true" data-type="parallelogram">
                    <i class="fas fa-shapes"></i>
                    <span>Parallelogram</span>
                </div>
                <div class="tool-item" draggable="true" data-type="circle">
                    <i class="fas fa-circle"></i>
                    <span>Circle</span>
                </div>
                <div class="tool-item" draggable="true" data-type="pentagon">
                    <i class="fas fa-stop"></i>
                    <span>Pentagon</span>
                </div>
                <div class="tool-item" draggable="true" data-type="hexagon">
                    <i class="fas fa-hexagon"></i>
                    <span>Hexagon</span>
                </div>
            </div>

            <!-- 3D Shapes -->
            <div class="tool-category">
                <h6><i class="fas fa-cube me-2"></i>3D Shapes</h6>
                <div class="tool-item" draggable="true" data-type="cube">
                    <i class="fas fa-cube"></i>
                    <span>Cube</span>
                </div>
                <div class="tool-item" draggable="true" data-type="sphere">
                    <i class="fas fa-globe"></i>
                    <span>Sphere</span>
                </div>
                <div class="tool-item" draggable="true" data-type="cuboid">
                    <i class="fas fa-box"></i>
                    <span>Cuboid</span>
                </div>
            </div>

            <!-- Charts -->
            <div class="tool-category">
                <h6>Charts & Graphs</h6>
                <div class="tool-item" draggable="true" data-type="bar-chart">
                    <i class="fas fa-chart-bar"></i>
                    <span>Bar Chart</span>
                </div>
                <div class="tool-item" draggable="true" data-type="line-chart">
                    <i class="fas fa-chart-line"></i>
                    <span>Line Chart</span>
                </div>
                <div class="tool-item" draggable="true" data-type="pie-chart">
                    <i class="fas fa-chart-pie"></i>
                    <span>Pie Chart</span>
                </div>
            </div>
            
            <!-- Math & Science -->
            <div class="tool-category">
                <h6>Math & Science</h6>
                <div class="tool-item" draggable="true" data-type="latex">
                    <i class="fas fa-square-root-alt"></i>
                    <span>LaTeX Formula</span>
                </div>
                <div class="tool-item" draggable="true" data-type="equation">
                    <i class="fas fa-calculator"></i>
                    <span>Equation</span>
                </div>
            </div>
            
            <!-- Questions -->
            <div class="tool-category">
                <h6>Questions</h6>
                <div class="tool-item" draggable="true" data-type="question">
                    <i class="fas fa-question-circle"></i>
                    <span>Main Question</span>
                </div>
                <div class="tool-item" draggable="true" data-type="sub-question">
                    <i class="fas fa-list-ol"></i>
                    <span>Sub Question</span>
                </div>
                <div class="tool-item" draggable="true" data-type="answer-area">
                    <i class="fas fa-edit"></i>
                    <span>Answer Area</span>
                </div>
            </div>

            <!-- Math Elements -->
            <div class="tool-category">
                <div class="math-category-header" onclick="toggleMathCategory()" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 8px 0;">
                    <h6 style="margin: 0; color: #4f46e5;">
                        <i class="fas fa-calculator me-2"></i>Math
                    </h6>
                    <i class="fas fa-chevron-down" id="math-chevron" style="transition: transform 0.3s ease; color: #6b7280;"></i>
                </div>

                <div id="math-elements" style="display: none; margin-top: 8px;">
                    <!-- Basic Elements -->
                    <div class="math-subcategory">
                        <h6 class="math-subcategory-title">Basic Elements</h6>
                        <div class="tool-item" draggable="true" data-type="math-number">
                            <i class="fas fa-hashtag"></i>
                            <span>Number</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-fraction">
                            <i class="fas fa-divide"></i>
                            <span>Fraction</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-equation">
                            <i class="fas fa-equals"></i>
                            <span>Equation</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-expression">
                            <i class="fas fa-function"></i>
                            <span>Expression</span>
                        </div>
                    </div>

                    <!-- Geometric Shapes -->
                    <div class="math-subcategory">
                        <h6 class="math-subcategory-title">Geometric Shapes</h6>
                        <div class="tool-item" draggable="true" data-type="math-triangle">
                            <i class="fas fa-play" style="transform: rotate(90deg);"></i>
                            <span>Triangle</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-square">
                            <i class="fas fa-square"></i>
                            <span>Square</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-circle">
                            <i class="fas fa-circle"></i>
                            <span>Circle</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-rectangle">
                            <i class="fas fa-rectangle-landscape"></i>
                            <span>Rectangle</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-polygon">
                            <i class="fas fa-draw-polygon"></i>
                            <span>Polygon</span>
                        </div>
                    </div>

                    <!-- 3D Shapes -->
                    <div class="math-subcategory">
                        <h6 class="math-subcategory-title">3D Shapes</h6>
                        <div class="tool-item" draggable="true" data-type="math-cube">
                            <i class="fas fa-cube"></i>
                            <span>Cube</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-sphere">
                            <i class="fas fa-globe"></i>
                            <span>Sphere</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-cylinder">
                            <i class="fas fa-database"></i>
                            <span>Cylinder</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-cone">
                            <i class="fas fa-triangle"></i>
                            <span>Cone</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-pyramid">
                            <i class="fas fa-mountain"></i>
                            <span>Pyramid</span>
                        </div>
                    </div>

                    <!-- Charts and Graphs -->
                    <div class="math-subcategory">
                        <h6 class="math-subcategory-title">Charts and Graphs</h6>
                        <div class="tool-item" draggable="true" data-type="math-bar-chart">
                            <i class="fas fa-chart-bar"></i>
                            <span>Bar Chart</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-line-graph">
                            <i class="fas fa-chart-line"></i>
                            <span>Line Graph</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-pie-chart">
                            <i class="fas fa-chart-pie"></i>
                            <span>Pie Chart</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-coordinate-grid">
                            <i class="fas fa-border-all"></i>
                            <span>Coordinate Grid</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-scatter-plot">
                            <i class="fas fa-braille"></i>
                            <span>Scatter Plot</span>
                        </div>
                    </div>

                    <!-- Math Science -->
                    <div class="math-subcategory">
                        <h6 class="math-subcategory-title">Math Science</h6>
                        <div class="tool-item" draggable="true" data-type="math-formula">
                            <i class="fas fa-square-root-alt"></i>
                            <span>Formula</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-measurement">
                            <i class="fas fa-ruler"></i>
                            <span>Measurement</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-angle">
                            <i class="fas fa-angle-right"></i>
                            <span>Angle</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-vector">
                            <i class="fas fa-arrow-right"></i>
                            <span>Vector</span>
                        </div>
                        <div class="tool-item" draggable="true" data-type="math-matrix">
                            <i class="fas fa-th"></i>
                            <span>Matrix</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-header">
                <h5 class="canvas-title">Complex Quiz Builder</h5>
                <div class="canvas-actions">
                    <button class="btn-canvas btn-secondary-canvas" onclick="testDragDrop()" title="Test drag and drop functionality">
                        <i class="fas fa-bug me-1"></i>Test
                    </button>
                    <button class="btn-canvas btn-secondary-canvas" onclick="clearCanvas()">
                        <i class="fas fa-trash me-1"></i>Clear
                    </button>

                    <!-- Question Navigation -->
                    <div class="btn-group" style="margin: 0 10px;">
                        <button class="btn-canvas btn-navigation-canvas" onclick="previousQuestion()" id="prev-question-btn" title="Go to previous question" disabled>
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <span class="question-counter" id="question-counter">Q1</span>
                        <button class="btn-canvas btn-navigation-canvas" onclick="nextQuestion()" id="next-question-btn" title="Go to next question">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>

                    <button class="btn-canvas btn-secondary-canvas" onclick="previewQuiz()">
                        <i class="fas fa-eye me-1"></i>Preview
                    </button>
                    <button class="btn-canvas btn-warning-canvas" onclick="exportToPDF()" title="Export quiz as PDF">
                        <i class="fas fa-file-pdf me-1"></i>Save as PDF
                    </button>
                    <button class="btn-canvas btn-info-canvas" onclick="openQuizSettings()">
                        <i class="fas fa-cog me-1"></i>Quiz Settings
                    </button>
                    <button class="btn-canvas btn-success-canvas" onclick="saveQuiz()" style="background: #28a745; font-weight: 600;">
                        <i class="fas fa-check me-1"></i>Complete Quiz
                    </button>
                </div>
            </div>

            <div class="canvas-workspace">
                <div class="canvas-area" id="canvas">
                    <div class="canvas-placeholder">
                        <i class="fas fa-mouse-pointer"></i>
                        <h5>Start Building Your Quiz</h5>
                        <p>Drag and drop elements from the sidebar to create your complex quiz</p>
                        <p><small><strong>Tip:</strong> You can also click on any tool in the sidebar to add it to the center of the canvas</small></p>
                        <div style="margin-top: 15px;">
                            <button class="btn btn-primary btn-sm" onclick="addElementToCanvas('textbox')">
                                <i class="fas fa-font me-1"></i>Add Text Box
                            </button>
                            <button class="btn btn-outline-primary btn-sm ms-2" onclick="addElementToCanvas('question')">
                                <i class="fas fa-question-circle me-1"></i>Add Question
                            </button>
                        </div>
                        <div style="margin-top: 10px;">
                            <small class="text-muted">Quick Shapes:</small><br>
                            <button class="btn btn-outline-secondary btn-sm me-1 mt-1" onclick="addElementToCanvas('circle')" title="Add Circle">
                                <i class="fas fa-circle"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm me-1 mt-1" onclick="addElementToCanvas('square')" title="Add Square">
                                <i class="fas fa-square"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm me-1 mt-1" onclick="addElementToCanvas('rectangle')" title="Add Rectangle">
                                <i class="far fa-square"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm me-1 mt-1" onclick="addElementToCanvas('rhombus')" title="Add Rhombus">
                                <i class="fas fa-gem"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm me-1 mt-1" onclick="addElementToCanvas('triangle')" title="Add Triangle">
                                <i class="fas fa-play" style="transform: rotate(90deg);"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm me-1 mt-1" onclick="addElementToCanvas('line')" title="Add Line">
                                <i class="fas fa-minus"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm me-1 mt-1" onclick="addElementToCanvas('cube')" title="Add Cube">
                                <i class="fas fa-cube"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="properties-panel">
            <div class="properties-header">
                <h5><i class="fas fa-cog me-2"></i>Element Properties</h5>
            </div>
            <div class="properties-content" id="properties-content">
                <div class="text-center text-muted">
                    <i class="fas fa-hand-pointer fa-2x mb-3"></i>
                    <p>Select an element to edit its properties</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Quiz Settings Modal -->
    <div class="modal fade" id="quizSettingsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Quiz Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="quizTitle" class="form-label">Quiz Title *</label>
                                <input type="text" class="form-control" id="quizTitle" required>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="quizGrade" class="form-label">Grade Level *</label>
                                <select class="form-select" id="quizGrade" required>
                                    <option value="">Select Grade</option>
                                    <option value="1st grade">1st Grade</option>
                                    <option value="2nd grade">2nd Grade</option>
                                    <option value="3rd grade">3rd Grade</option>
                                    <option value="4th grade">4th Grade</option>
                                    <option value="5th grade">5th Grade</option>
                                    <option value="6th grade">6th Grade</option>
                                    <option value="7th grade">7th Grade</option>
                                    <option value="8th grade">8th Grade</option>
                                    <option value="9th grade">9th Grade</option>
                                    <option value="10th grade">10th Grade</option>
                                    <option value="11th grade">11th Grade</option>
                                    <option value="12th grade">12th Grade</option>
                                    <option value="Young Adult Education">Young Adult Education</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="quizSubject" class="form-label">Subject *</label>
                                <select class="form-select" id="quizSubject" required>
                                    <option value="">Select Subject</option>
                                    <option value="English">English</option>
                                    <option value="Science">Science</option>
                                    <option value="Math">Math</option>
                                    <option value="Python">Python</option>
                                    <option value="Tableau">Tableau</option>
                                    <option value="Power BI">Power BI</option>
                                </select>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="quizType" class="form-label">Quiz Type *</label>
                                <select class="form-select" id="quizType" required>
                                    <option value="regular">Regular Quiz</option>
                                    <option value="competitive">Competitive Quiz</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="quizDescription" class="form-label">Description</label>
                        <textarea class="form-control" id="quizDescription" rows="3" placeholder="Enter quiz description..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveQuizSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let selectedElement = null;
        let elementCounter = 0;
        let quizElements = [];
        let quizSettings = {
            title: '',
            description: '',
            gradeLevel: '',
            subject: '',
            quizType: 'regular'
        };



        // Error handler
        window.addEventListener('error', function(e) {
            console.error('JavaScript Error:', e.error);
            console.error('Error details:', e.message, 'at', e.filename, ':', e.lineno);
        });

        // Load MathJax dynamically when needed
        function loadMathJax() {
            if (window.MathJax) return Promise.resolve();

            return new Promise((resolve, reject) => {
                window.MathJax = {
                    tex: {
                        inlineMath: [['$', '$'], ['\\(', '\\)']],
                        displayMath: [['$$', '$$'], ['\\[', '\\]']]
                    },
                    startup: {
                        ready: () => {
                            MathJax.startup.defaultReady();
                            resolve();
                        }
                    }
                };

                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
                script.async = true;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Initialize the quiz builder
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing quiz builder...');

            try {
                // Wait a bit for all elements to be ready
                setTimeout(() => {
                    initializeDragAndDrop();
                    setupCanvasEvents();

                    // Show quiz settings modal on load
                    const modal = new bootstrap.Modal(document.getElementById('quizSettingsModal'));
                    modal.show();

                    // Test that functions are available
                    console.log('Functions available:', {
                        addElementToCanvas: typeof window.addElementToCanvas,
                        testDragDrop: typeof window.testDragDrop,
                        clearCanvas: typeof window.clearCanvas,
                        saveQuiz: typeof window.saveQuiz
                    });

                    console.log('Quiz builder initialized successfully');

                    // Initialize question navigation
                    initializeQuestionNavigation();
                }, 100);
            } catch (error) {
                console.error('Error initializing quiz builder:', error);
                alert('Error initializing quiz builder. Please refresh the page.');
            }
        });

        // Initialize drag and drop functionality
        function initializeDragAndDrop() {
            const toolItems = document.querySelectorAll('.tool-item');
            const canvas = document.getElementById('canvas');

            console.log('Found tool items:', toolItems.length);
            console.log('Canvas element:', canvas);

            // Add drag start event to tool items
            toolItems.forEach((item, index) => {
                if (!item) {
                    console.warn(`Null tool item found at index ${index}, skipping`);
                    return;
                }

                console.log(`Setting up tool item ${index}:`, item.dataset.type);

                // Ensure the item is draggable
                item.draggable = true;

                // Add event listeners with error handling
                try {
                    item.addEventListener('dragstart', handleDragStart);

                    // Add visual feedback
                    item.addEventListener('dragend', function() {
                        console.log('Drag ended for:', item.dataset.type);
                    });

                    // Add click handler for mobile/touch devices
                    item.addEventListener('click', function(e) {
                        if (e.detail === 2) { // Double click
                            console.log('Double clicked tool:', item.dataset.type);
                            // Create element in center of canvas for double-click
                            createElement(item.dataset.type, 400, 300);
                        }
                    });
                } catch (error) {
                    console.error(`Error adding event listeners to tool item ${index}:`, error);
                }
            });

            if (canvas) {
                try {
                    // Add drop events to canvas
                    canvas.addEventListener('dragover', handleDragOver);
                    canvas.addEventListener('drop', handleDrop);
                    canvas.addEventListener('dragenter', handleDragEnter);
                    canvas.addEventListener('dragleave', handleDragLeave);

                    console.log('Canvas drop events attached');
                } catch (error) {
                    console.error('Error adding canvas event listeners:', error);
                }
            } else {
                console.error('Canvas element not found!');
            }
        }

        function handleDragStart(e) {
            console.log('Drag start:', e.target.dataset.type);

            // Get the tool item element (might be the span or i inside)
            let toolItem = e.target;
            if (!toolItem.dataset.type) {
                toolItem = toolItem.closest('.tool-item');
            }

            if (toolItem && toolItem.dataset.type) {
                e.dataTransfer.setData('text/plain', toolItem.dataset.type);
                e.dataTransfer.effectAllowed = 'copy';
                console.log('Setting data type:', toolItem.dataset.type);
            } else {
                console.error('No data type found');
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const canvas = document.getElementById('canvas');
            canvas.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();

            // Check if we're leaving the canvas area
            if (e.clientX < rect.left || e.clientX > rect.right ||
                e.clientY < rect.top || e.clientY > rect.bottom) {
                canvas.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            console.log('Drop event triggered');

            const canvas = document.getElementById('canvas');
            canvas.classList.remove('drag-over');

            const elementType = e.dataTransfer.getData('text/plain');
            console.log('Dropped element type:', elementType);

            if (!elementType) {
                console.error('No element type in drop data');
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            console.log('Drop position:', x, y);
            createElement(elementType, x, y);
        }

        // Setup canvas events
        function setupCanvasEvents() {
            const canvas = document.getElementById('canvas');

            if (!canvas) {
                console.error('Canvas element not found in setupCanvasEvents');
                return;
            }

            try {
                // Deselect elements when clicking on canvas
                canvas.addEventListener('click', function(e) {
                    console.log('Canvas clicked:', e.target);
                    if (e.target === canvas || e.target.classList.contains('canvas-placeholder')) {
                        deselectAllElements();
                    }
                });
            } catch (error) {
                console.error('Error adding canvas click listener:', error);
            }

            // Make placeholder clickable to show instructions
            const placeholder = document.querySelector('.canvas-placeholder');
            if (placeholder) {
                try {
                    placeholder.addEventListener('click', function(e) {
                        e.stopPropagation();
                        showCanvasInstructions();
                    });

                    // Make placeholder more interactive
                    placeholder.style.cursor = 'pointer';
                    placeholder.style.transition = 'all 0.3s ease';

                    placeholder.addEventListener('mouseenter', function() {
                        this.style.transform = 'translate(-50%, -50%) scale(1.05)';
                        this.style.opacity = '0.8';
                    });

                    placeholder.addEventListener('mouseleave', function() {
                        this.style.transform = 'translate(-50%, -50%) scale(1)';
                        this.style.opacity = '1';
                    });
                } catch (error) {
                    console.error('Error adding placeholder event listeners:', error);
                }
            }
        }

        // Show canvas instructions
        function showCanvasInstructions() {
            alert(' How to use the Quiz Builder:\n\n' +
                '1.  Drag any tool from the left sidebar\n' +
                '2.  Drop it anywhere on this canvas\n' +
                '3.  Click on elements to select and edit them\n' +
                '4.  Use the properties panel on the right to customize\n' +
                '5.  Drag elements around to reposition them\n' +
                '6.  Use the delete button to remove elements\n\n' +
                'Try dragging a "Text Box" or "Question" to get started!');
        }

        // Fallback method to add elements by clicking (for touch devices or if drag fails)
        function addElementToCanvas(elementType) {
            console.log('Adding element via click:', elementType);
            // Add element to center of canvas
            createElement(elementType, 400, 300);
        }

        // Make this function globally available immediately
        window.addElementToCanvas = addElementToCanvas;

        // Test function to verify drag and drop is working
        function testDragDrop() {
            try {
                console.log('Testing drag and drop functionality...');

                // Test creating different elements including shapes
                createElement('textbox', 100, 100);
                createElement('question', 300, 200);
                createElement('circle', 500, 150);
                createElement('triangle', 150, 300);
                createElement('cube', 400, 350);

                console.log('Test elements created. Current elements:', quizElements.length);

                alert('Test completed! Created ' + quizElements.length + ' elements including geometric shapes on the canvas. Check the console for detailed logs.');
            } catch (error) {
                console.error('Error in test function:', error);
                alert('Test failed: ' + error.message);
            }
        }

        // Make this function globally available immediately
        window.testDragDrop = testDragDrop;

        // Create new element on canvas
        function createElement(type, x, y) {
            console.log('Creating element:', type, 'at position:', x, y);

            if (!type) {
                console.error('No element type provided');
                alert('Error: No element type specified');
                return;
            }

            elementCounter++;
            const elementId = `element-${elementCounter}`;

            // Adjust dimensions based on element type
            let width = 200, height = 100;
            switch(type) {
                case 'question':
                case 'sub-question':
                    width = 400;
                    height = 120;
                    break;
                case 'table':
                    width = 300;
                    height = 150;
                    break;
                case 'latex':
                    width = 250;
                    height = 80;
                    break;
                case 'answer-area':
                    width = 350;
                    height = 100;
                    break;
                // 2D Shapes
                case 'line':
                    width = 200;
                    height = 20;
                    break;
                case 'triangle':
                case 'square':
                case 'circle':
                case 'pentagon':
                case 'hexagon':
                    width = 150;
                    height = 150;
                    break;
                case 'rectangle':
                case 'rhombus':
                case 'parallelogram':
                    width = 200;
                    height = 120;
                    break;
                // 3D Shapes
                case 'cube':
                case 'sphere':
                    width = 150;
                    height = 150;
                    break;
                case 'cuboid':
                    width = 200;
                    height = 120;
                    break;
                // Charts
                case 'bar-chart':
                case 'line-chart':
                case 'pie-chart':
                    width = 300;
                    height = 200;
                    break;
                // Math Elements - Basic
                case 'math-number':
                case 'math-fraction':
                case 'math-equation':
                case 'math-expression':
                case 'math-formula':
                    width = 200;
                    height = 80;
                    break;
                // Math Elements - Geometric Shapes
                case 'math-triangle':
                case 'math-square':
                case 'math-circle':
                case 'math-rectangle':
                case 'math-polygon':
                    width = 120;
                    height = 120;
                    break;
                // Math Elements - 3D Shapes
                case 'math-cube':
                case 'math-sphere':
                case 'math-cylinder':
                case 'math-cone':
                case 'math-pyramid':
                    width = 140;
                    height = 140;
                    break;
                // Math Elements - Charts and Graphs
                case 'math-bar-chart':
                case 'math-line-graph':
                case 'math-pie-chart':
                case 'math-coordinate-grid':
                case 'math-scatter-plot':
                    width = 300;
                    height = 200;
                    break;
                // Math Elements - Math Science
                case 'math-measurement':
                case 'math-angle':
                case 'math-vector':
                case 'math-matrix':
                    width = 180;
                    height = 120;
                    break;
            }

            const element = {
                id: elementId,
                type: type,
                x: Math.max(0, x - width/2), // Center the element on drop point
                y: Math.max(0, y - height/2),
                width: width,
                height: height,
                content: '',
                style: {
                    fontSize: '14px',
                    fontFamily: 'Inter',
                    color: '#1e293b',
                    backgroundColor: '#ffffff',
                    border: '1px solid #e2e8f0',
                    borderRadius: '6px',
                    padding: '10px'
                }
            };

            console.log('Element created:', element);

            // Add to global quizElements for compatibility
            quizElements.push(element);

            // Add to current page
            if (questionPages[currentQuestionIndex]) {
                questionPages[currentQuestionIndex].elements.push(element);
                console.log('Added element to existing page', currentQuestionIndex);
            } else {
                // Create first page if it doesn't exist
                createNewQuestionPage();
                questionPages[currentQuestionIndex].elements.push(element);
                console.log('Created new page and added element');
            }

            renderElement(element);
            selectElement(elementId);

            // Hide placeholder if this is the first element
            if (quizElements.length === 1) {
                const placeholder = document.querySelector('.canvas-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
            }

            console.log('Total elements:', quizElements.length);
            console.log('Current page elements:', questionPages[currentQuestionIndex]?.elements.length);
        }

        // Render element on canvas
        function renderElement(element) {
            console.log('Rendering element:', element.id, element.type);

            const canvas = document.getElementById('canvas');
            if (!canvas) {
                console.error('Canvas not found!');
                return;
            }

            // Check if element already exists
            const existingElement = document.getElementById(element.id);
            if (existingElement) {
                console.log('Element already exists, removing old version');
                existingElement.remove();
            }

            const elementDiv = document.createElement('div');
            elementDiv.className = 'canvas-element';
            elementDiv.id = element.id;
            elementDiv.style.left = element.x + 'px';
            elementDiv.style.top = element.y + 'px';
            elementDiv.style.width = element.width + 'px';
            elementDiv.style.height = element.height + 'px';
            elementDiv.style.position = 'absolute';
            elementDiv.style.zIndex = '10';

            // Apply styles
            Object.assign(elementDiv.style, element.style);

            // Add content based on type
            try {
                elementDiv.innerHTML = getElementContent(element);
            } catch (error) {
                console.error('Error generating content for element:', error);
                elementDiv.innerHTML = `<div style="padding: 10px; color: red;">Error loading ${element.type}</div>`;
            }

            // Add controls
            const controls = document.createElement('div');
            controls.className = 'element-controls';
            controls.innerHTML = `
                <button class="control-btn" onclick="duplicateElement('${element.id}')" title="Duplicate">
                    <i class="fas fa-copy"></i>
                </button>
                <button class="control-btn delete" onclick="deleteElement('${element.id}')" title="Delete">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            elementDiv.appendChild(controls);

            // Add click event with null check
            if (elementDiv) {
                try {
                    elementDiv.addEventListener('click', (e) => {
                        e.stopPropagation();
                        console.log('Element clicked:', element.id);
                        selectElement(element.id);
                    });
                } catch (error) {
                    console.error('Error adding click listener to element:', element.id, error);
                }
            }

            // Make draggable within canvas
            makeDraggable(elementDiv);

            canvas.appendChild(elementDiv);
            console.log('Element rendered successfully:', element.id);

            // Set up auto-save listeners for this element
            setupAutoSaveListeners(elementDiv);

            // Special handling for LaTeX elements
            if (element.type === 'latex') {
                loadMathJax().then(() => {
                    if (window.MathJax && MathJax.typesetPromise) {
                        MathJax.typesetPromise([elementDiv]).catch(console.error);
                    }
                }).catch(console.error);
            }
        }

        // Get content for different element types
        function getElementContent(element) {
            switch(element.type) {
                case 'textbox':
                    return `<div contenteditable="true" style="outline: none; width: 100%; height: 100%;">${element.content || 'Click to edit text...'}</div>`;
                case 'image':
                    if (element.content && element.content.startsWith('data:image')) {
                        // Enhanced data URL validation
                        const isValidDataURL = element.content.includes(',') &&
                                             element.content.length > 100 &&
                                             element.content.match(/^data:image\/(jpeg|jpg|png|gif|webp);base64,/);

                        if (!isValidDataURL) {
                            console.warn('Invalid data URL detected for element:', element.id, 'Length:', element.content.length);
                            return `<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #fee2e2; border: 2px dashed #ef4444; cursor: pointer; overflow: hidden;" onclick="event.stopPropagation(); triggerImageUpload('${element.id}')">
                                <div style="text-align: center; color: #dc2626;">
                                    <i class="fas fa-exclamation-triangle fa-2x mb-2"></i><br>
                                    <small>Invalid image data<br>Click to re-upload</small>
                                </div>
                            </div>`;
                        }

                        const objectFit = element.objectFit || 'contain';
                        const objectPosition = element.objectPosition || 'center';

                        // Create a safe data URL by ensuring it's properly formatted
                        let safeDataURL = element.content;
                        try {
                            // Test if the data URL can be used by creating a temporary image
                            const testImg = new Image();
                            testImg.src = safeDataURL;
                        } catch (error) {
                            console.warn('Data URL failed validation test:', error);
                            return `<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #fee2e2; border: 2px dashed #ef4444; cursor: pointer; overflow: hidden;" onclick="event.stopPropagation(); triggerImageUpload('${element.id}')">
                                <div style="text-align: center; color: #dc2626;">
                                    <i class="fas fa-exclamation-triangle fa-2x mb-2"></i><br>
                                    <small>Corrupted image data<br>Click to re-upload</small>
                                </div>
                            </div>`;
                        }

                        return `<div style="position: relative; width: 100%; height: 100%; overflow: hidden; border-radius: 4px;">
                            <img src="${safeDataURL}" style="width: 100%; height: 100%; object-fit: ${objectFit}; object-position: ${objectPosition}; border-radius: 4px; display: block;" onclick="event.stopPropagation(); triggerImageUpload('${element.id}')" onerror="this.parentElement.innerHTML='<div style=\\'display: flex; align-items: center; justify-content: center; height: 100%; background: #fee2e2; border: 2px dashed #ef4444; cursor: pointer;\\' onclick=\\'event.stopPropagation(); triggerImageUpload(\\'${element.id}\\');\\'><div style=\\'text-align: center; color: #dc2626;\\'><i class=\\'fas fa-exclamation-triangle fa-2x mb-2\\'></i><br><small>Image load error<br>Click to re-upload</small></div></div>';">
                            <div style="position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; cursor: pointer;" onclick="event.stopPropagation(); triggerImageUpload('${element.id}')">
                                <i class="fas fa-edit"></i> Change
                            </div>
                        </div>`;
                    } else {
                        return `<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f8fafc; border: 2px dashed #cbd5e1; cursor: pointer; overflow: hidden;" onclick="event.stopPropagation(); triggerImageUpload('${element.id}')">
                            <div style="text-align: center; color: #64748b;">
                                <i class="fas fa-image fa-2x mb-2"></i><br>
                                <small>Click to upload image</small>
                            </div>
                        </div>`;
                    }
                case 'table':
                    return `<table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <td contenteditable="true" style="border: 1px solid #e2e8f0; padding: 8px; outline: none;" onclick="event.stopPropagation()">Cell 1</td>
                            <td contenteditable="true" style="border: 1px solid #e2e8f0; padding: 8px; outline: none;" onclick="event.stopPropagation()">Cell 2</td>
                        </tr>
                        <tr>
                            <td contenteditable="true" style="border: 1px solid #e2e8f0; padding: 8px; outline: none;" onclick="event.stopPropagation()">Cell 3</td>
                            <td contenteditable="true" style="border: 1px solid #e2e8f0; padding: 8px; outline: none;" onclick="event.stopPropagation()">Cell 4</td>
                        </tr>
                    </table>`;
                case 'question':
                    return `<div style="padding: 15px; background: #f0f9ff; border-left: 4px solid #0ea5e9;">
                        <strong>Question ${quizElements.filter(e => e.type === 'question').length}:</strong>
                        <div contenteditable="true" style="outline: none; margin-top: 8px;">${element.content || 'Enter your question here...'}</div>
                    </div>`;
                case 'sub-question':
                    return `<div style="padding: 12px; background: #fefce8; border-left: 4px solid #eab308; margin-left: 20px;">
                        <strong>Sub-question:</strong>
                        <div contenteditable="true" style="outline: none; margin-top: 8px;">${element.content || 'Enter sub-question here...'}</div>
                    </div>`;
                case 'latex':
                    return `<div style="padding: 15px; background: #f8fafc; border: 1px solid #e2e8f0; text-align: center;">
                        <div id="latex-${element.id}" style="font-size: 16px;">$$${element.content || 'x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}'}$$</div>
                        <small style="color: #64748b;">LaTeX Formula</small>
                    </div>`;
                case 'bar-chart':
                case 'line-chart':
                case 'pie-chart':
                    // Render chart and schedule Chart.js initialization
                    setTimeout(() => renderChart(element), 100);
                    return `<div style="padding: 15px; background: #f8fafc; border: 1px solid #e2e8f0; height: 100%; box-sizing: border-box;">
                        <canvas id="chart-${element.id}" style="width: 100%; height: calc(100% - 40px);"></canvas>
                        <small style="color: #64748b; display: block; text-align: center; margin-top: 8px;">${element.type.replace('-', ' ').toUpperCase()}</small>
                    </div>`;
                case 'answer-area':
                    return `<div style="padding: 15px; background: #f0fdf4; border: 2px dashed #22c55e; border-radius: 8px;">
                        <div style="color: #16a34a; font-weight: 600; margin-bottom: 8px;">
                            <i class="fas fa-edit me-2"></i>Answer Area
                        </div>
                        <textarea style="width: 100%; height: 60px; border: 1px solid #e2e8f0; border-radius: 4px; padding: 8px; resize: vertical;" placeholder="Students will write their answer here..."></textarea>
                    </div>`;

                // 2D Geometric Shapes
                case 'line':
                    const lineLength = element.shapeLength || 180;
                    const lineViewBox = `0 0 ${lineLength + 20} 20`;
                    const lineX2 = lineLength + 10;
                    return `<svg width="100%" height="100%" viewBox="${lineViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <line x1="10" y1="10" x2="${lineX2}" y2="10"
                              stroke="${element.strokeColor || '#3b82f6'}"
                              stroke-width="${element.strokeWidth || 2}"
                              ${element.strokeDasharray ? `stroke-dasharray="${element.strokeDasharray}"` : ''} />
                        <text x="${(lineLength + 20) / 2}" y="18" text-anchor="middle" font-size="10" fill="#64748b">Line (${lineLength}px)</text>
                    </svg>`;

                case 'triangle':
                    const baseWidth = element.shapeBaseWidth || 110;
                    const triangleHeight = element.shapeHeight || 110;
                    const triangleViewBox = `0 0 ${baseWidth + 20} ${triangleHeight + 30}`;
                    const topX = (baseWidth + 20) / 2;
                    const topY = 10;
                    const leftX = 10;
                    const rightX = baseWidth + 10;
                    const bottomY = triangleHeight + 10;
                    return `<svg width="100%" height="100%" viewBox="${triangleViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <polygon points="${topX},${topY} ${leftX},${bottomY} ${rightX},${bottomY}"
                                fill="${element.fillColor || '#dbeafe'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${topX}" y="${triangleHeight + 25}" text-anchor="middle" font-size="10" fill="#64748b">Triangle (${baseWidth}${triangleHeight}px)</text>
                    </svg>`;

                case 'square':
                    const sideLength = element.shapeSideLength || 100;
                    const squareViewBox = `0 0 ${sideLength + 20} ${sideLength + 30}`;
                    const squareX = 10;
                    const squareY = 10;
                    return `<svg width="100%" height="100%" viewBox="${squareViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <rect x="${squareX}" y="${squareY}" width="${sideLength}" height="${sideLength}"
                              fill="${element.fillColor || '#dbeafe'}"
                              stroke="${element.strokeColor || '#3b82f6'}"
                              stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(sideLength + 20) / 2}" y="${sideLength + 25}" text-anchor="middle" font-size="10" fill="#64748b">Square (${sideLength}${sideLength}px)</text>
                    </svg>`;

                case 'rectangle':
                    const rectWidth = element.shapeWidth || 160;
                    const rectHeight = element.shapeHeight || 100;
                    const rectViewBox = `0 0 ${rectWidth + 20} ${rectHeight + 30}`;
                    const rectX = 10;
                    const rectY = 10;
                    return `<svg width="100%" height="100%" viewBox="${rectViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <rect x="${rectX}" y="${rectY}" width="${rectWidth}" height="${rectHeight}"
                              fill="${element.fillColor || '#dbeafe'}"
                              stroke="${element.strokeColor || '#3b82f6'}"
                              stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(rectWidth + 20) / 2}" y="${rectHeight + 25}" text-anchor="middle" font-size="10" fill="#64748b">Rectangle (${rectWidth}${rectHeight}px)</text>
                    </svg>`;

                case 'rhombus':
                    const rhombusWidth = element.shapeWidth || 140;
                    const rhombusHeight = element.shapeHeight || 100;
                    const rhombusViewBox = `0 0 ${rhombusWidth + 20} ${rhombusHeight + 30}`;
                    const rhombusCenterX = (rhombusWidth + 20) / 2;
                    const rhombusCenterY = rhombusHeight / 2 + 10;
                    const rhombusHalfWidth = rhombusWidth / 2;
                    const rhombusHalfHeight = rhombusHeight / 2;
                    // Calculate rhombus points (diamond shape)
                    const rhombusTop = `${rhombusCenterX},${rhombusCenterY - rhombusHalfHeight}`;
                    const rhombusRight = `${rhombusCenterX + rhombusHalfWidth},${rhombusCenterY}`;
                    const rhombusBottom = `${rhombusCenterX},${rhombusCenterY + rhombusHalfHeight}`;
                    const rhombusLeft = `${rhombusCenterX - rhombusHalfWidth},${rhombusCenterY}`;
                    return `<svg width="100%" height="100%" viewBox="${rhombusViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <polygon points="${rhombusTop} ${rhombusRight} ${rhombusBottom} ${rhombusLeft}"
                                fill="${element.fillColor || '#dbeafe'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${rhombusCenterX}" y="${rhombusHeight + 25}" text-anchor="middle" font-size="10" fill="#64748b">Rhombus (${rhombusWidth}${rhombusHeight}px)</text>
                    </svg>`;

                case 'parallelogram':
                    const paraWidth = element.shapeWidth || 160;
                    const paraHeight = element.shapeHeight || 80;
                    const paraViewBox = `0 0 ${paraWidth + 40} ${paraHeight + 30}`;
                    const skew = 20; // Fixed skew amount for parallelogram effect
                    const topLeft = `${skew + 10},10`;
                    const topRight = `${paraWidth + skew + 10},10`;
                    const bottomRight = `${paraWidth + 10},${paraHeight + 10}`;
                    const bottomLeft = `10,${paraHeight + 10}`;
                    return `<svg width="100%" height="100%" viewBox="${paraViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <polygon points="${topLeft} ${topRight} ${bottomRight} ${bottomLeft}"
                                fill="${element.fillColor || '#dbeafe'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(paraWidth + 40) / 2}" y="${paraHeight + 25}" text-anchor="middle" font-size="10" fill="#64748b">Parallelogram (${paraWidth}${paraHeight}px)</text>
                    </svg>`;

                case 'circle':
                    const diameter = element.shapeDiameter || 100;
                    const radius = diameter / 2;
                    const circleViewBox = `0 0 ${diameter + 20} ${diameter + 30}`;
                    const circleCx = (diameter + 20) / 2;
                    const circleCy = radius + 10;
                    return `<svg width="100%" height="100%" viewBox="${circleViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <circle cx="${circleCx}" cy="${circleCy}" r="${radius}"
                               fill="${element.fillColor || '#dbeafe'}"
                               stroke="${element.strokeColor || '#3b82f6'}"
                               stroke-width="${element.strokeWidth || 2}" />
                        <text x="${circleCx}" y="${diameter + 25}" text-anchor="middle" font-size="10" fill="#64748b">Circle (${diameter}px)</text>
                    </svg>`;

                case 'pentagon':
                    const pentSize = element.shapeSize || 90;
                    const pentViewBox = `0 0 ${pentSize + 20} ${pentSize + 30}`;
                    const pentCenterX = (pentSize + 20) / 2;
                    const pentCenterY = (pentSize + 20) / 2;
                    const pentRadius = pentSize / 2;
                    // Calculate pentagon points
                    const pentPoints = [];
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI / 5) - (Math.PI / 2);
                        const x = pentCenterX + pentRadius * Math.cos(angle);
                        const y = pentCenterY + pentRadius * Math.sin(angle);
                        pentPoints.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                    }
                    return `<svg width="100%" height="100%" viewBox="${pentViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <polygon points="${pentPoints.join(' ')}"
                                fill="${element.fillColor || '#dbeafe'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${pentCenterX}" y="${pentSize + 25}" text-anchor="middle" font-size="10" fill="#64748b">Pentagon (${pentSize}px)</text>
                    </svg>`;

                case 'hexagon':
                    const hexSize = element.shapeSize || 90;
                    const hexViewBox = `0 0 ${hexSize + 20} ${hexSize + 30}`;
                    const hexCenterX = (hexSize + 20) / 2;
                    const hexCenterY = (hexSize + 20) / 2;
                    const hexRadius = hexSize / 2;
                    // Calculate hexagon points
                    const hexPoints = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 2 * Math.PI / 6) - (Math.PI / 2);
                        const x = hexCenterX + hexRadius * Math.cos(angle);
                        const y = hexCenterY + hexRadius * Math.sin(angle);
                        hexPoints.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                    }
                    return `<svg width="100%" height="100%" viewBox="${hexViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <polygon points="${hexPoints.join(' ')}"
                                fill="${element.fillColor || '#dbeafe'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${hexCenterX}" y="${hexSize + 25}" text-anchor="middle" font-size="10" fill="#64748b">Hexagon (${hexSize}px)</text>
                    </svg>`;

                // 3D Shapes
                case 'cube':
                    const cubeSize = element.shapeSize || 80;
                    const cubeViewBox = `0 0 ${cubeSize + 40} ${cubeSize + 50}`;
                    const cubeDepth = cubeSize * 0.3; // 3D depth effect
                    const cubeFrontX = 20;
                    const cubeFrontY = cubeDepth + 20;
                    return `<svg width="100%" height="100%" viewBox="${cubeViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <!-- Front face -->
                        <rect x="${cubeFrontX}" y="${cubeFrontY}" width="${cubeSize}" height="${cubeSize}"
                              fill="${element.fillColor || '#dbeafe'}"
                              stroke="${element.strokeColor || '#3b82f6'}"
                              stroke-width="${element.strokeWidth || 2}" />
                        <!-- Top face -->
                        <polygon points="${cubeFrontX},${cubeFrontY} ${cubeFrontX + cubeDepth},${cubeFrontY - cubeDepth} ${cubeFrontX + cubeSize + cubeDepth},${cubeFrontY - cubeDepth} ${cubeFrontX + cubeSize},${cubeFrontY}"
                                fill="${element.fillColor || '#bfdbfe'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <!-- Right face -->
                        <polygon points="${cubeFrontX + cubeSize},${cubeFrontY} ${cubeFrontX + cubeSize + cubeDepth},${cubeFrontY - cubeDepth} ${cubeFrontX + cubeSize + cubeDepth},${cubeFrontY + cubeSize - cubeDepth} ${cubeFrontX + cubeSize},${cubeFrontY + cubeSize}"
                                fill="${element.fillColor || '#93c5fd'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(cubeSize + 40) / 2}" y="${cubeSize + cubeDepth + 35}" text-anchor="middle" font-size="10" fill="#64748b">Cube (${cubeSize}${cubeSize}${cubeSize}px)</text>
                    </svg>`;

                case 'sphere':
                    const sphereSize = element.shapeSize || 80;
                    const sphereRadius = sphereSize / 2;
                    const sphereViewBox = `0 0 ${sphereSize + 20} ${sphereSize + 30}`;
                    const sphereCx = (sphereSize + 20) / 2;
                    const sphereCy = sphereRadius + 10;
                    return `<svg width="100%" height="100%" viewBox="${sphereViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <defs>
                            <radialGradient id="sphereGradient-${element.id}" cx="0.3" cy="0.3">
                                <stop offset="0%" stop-color="${element.fillColor || '#ffffff'}" />
                                <stop offset="100%" stop-color="${element.fillColor || '#3b82f6'}" />
                            </radialGradient>
                        </defs>
                        <circle cx="${sphereCx}" cy="${sphereCy}" r="${sphereRadius}"
                               fill="url(#sphereGradient-${element.id})"
                               stroke="${element.strokeColor || '#3b82f6'}"
                               stroke-width="${element.strokeWidth || 2}" />
                        <text x="${sphereCx}" y="${sphereSize + 25}" text-anchor="middle" font-size="10" fill="#64748b">Sphere (${sphereSize}px)</text>
                    </svg>`;

                case 'cuboid':
                    const cuboidWidth = element.shapeWidth || 120;
                    const cuboidHeight = element.shapeHeight || 80;
                    const cuboidDepth = element.shapeDepth || 60;
                    const cuboidViewBox = `0 0 ${cuboidWidth + cuboidDepth + 20} ${cuboidHeight + cuboidDepth + 30}`;
                    const cuboidFrontX = 10;
                    const cuboidFrontY = cuboidDepth + 10;
                    return `<svg width="100%" height="100%" viewBox="${cuboidViewBox}" style="border: 1px solid #e2e8f0; background: #ffffff;">
                        <!-- Front face -->
                        <rect x="${cuboidFrontX}" y="${cuboidFrontY}" width="${cuboidWidth}" height="${cuboidHeight}"
                              fill="${element.fillColor || '#dbeafe'}"
                              stroke="${element.strokeColor || '#3b82f6'}"
                              stroke-width="${element.strokeWidth || 2}" />
                        <!-- Top face -->
                        <polygon points="${cuboidFrontX},${cuboidFrontY} ${cuboidFrontX + cuboidDepth},${cuboidFrontY - cuboidDepth} ${cuboidFrontX + cuboidWidth + cuboidDepth},${cuboidFrontY - cuboidDepth} ${cuboidFrontX + cuboidWidth},${cuboidFrontY}"
                                fill="${element.fillColor || '#bfdbfe'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <!-- Right face -->
                        <polygon points="${cuboidFrontX + cuboidWidth},${cuboidFrontY} ${cuboidFrontX + cuboidWidth + cuboidDepth},${cuboidFrontY - cuboidDepth} ${cuboidFrontX + cuboidWidth + cuboidDepth},${cuboidFrontY + cuboidHeight - cuboidDepth} ${cuboidFrontX + cuboidWidth},${cuboidFrontY + cuboidHeight}"
                                fill="${element.fillColor || '#93c5fd'}"
                                stroke="${element.strokeColor || '#3b82f6'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(cuboidWidth + cuboidDepth + 20) / 2}" y="${cuboidHeight + cuboidDepth + 25}" text-anchor="middle" font-size="10" fill="#64748b">Cuboid (${cuboidWidth}${cuboidHeight}${cuboidDepth}px)</text>
                    </svg>`;

                // Math Elements - Basic
                case 'math-number':
                    return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                        <div contenteditable="true" style="outline: none; font-size: 24px; font-weight: bold; color: #1e40af;">${element.content || '42'}</div>
                        <small style="color: #64748b;">Number</small>
                    </div>`;
                case 'math-fraction':
                    return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                        <div style="display: inline-block; text-align: center;">
                            <div contenteditable="true" style="outline: none; border-bottom: 2px solid #1e40af; padding: 5px; font-size: 18px; font-weight: bold;">${element.numerator || '3'}</div>
                            <div contenteditable="true" style="outline: none; padding: 5px; font-size: 18px; font-weight: bold;">${element.denominator || '4'}</div>
                        </div>
                        <br><small style="color: #64748b;">Fraction</small>
                    </div>`;
                case 'math-equation':
                    const equationType = element.equationType || 'simple';
                    let equationContent = element.content || 'x + 5 = 12';

                    if (equationType === 'complex') {
                        // Support for complex equations with LaTeX-like syntax
                        equationContent = element.content || '\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}';
                        return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                            <div id="equation-${element.id}" style="font-size: 18px; color: #1e40af; min-height: 40px; display: flex; align-items: center; justify-content: center;">
                                $$${equationContent}$$
                            </div>
                            <small style="color: #64748b;">Complex Equation</small>
                        </div>`;
                    } else {
                        return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                            <div contenteditable="true" style="outline: none; font-size: 18px; font-weight: bold; color: #1e40af;">${equationContent}</div>
                            <small style="color: #64748b;">Simple Equation</small>
                        </div>`;
                    }
                case 'math-expression':
                    return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                        <div contenteditable="true" style="outline: none; font-size: 18px; font-weight: bold; color: #1e40af;">${element.content || '2x + 3y'}</div>
                        <small style="color: #64748b;">Expression</small>
                    </div>`;
                case 'math-formula':
                    return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                        <div contenteditable="true" style="outline: none; font-size: 16px; font-weight: bold; color: #1e40af;">${element.content || 'A = r'}</div>
                        <small style="color: #64748b;">Formula</small>
                    </div>`;

                // Math Elements - Geometric Shapes
                case 'math-triangle':
                    const mathTriSize = element.shapeSize || 80;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathTriSize + 20} ${mathTriSize + 30}" style="border: 2px solid #10b981; background: #f0fdf4; border-radius: 8px;">
                        <polygon points="${(mathTriSize + 20) / 2},10 10,${mathTriSize} ${mathTriSize + 10},${mathTriSize}"
                                fill="${element.fillColor || '#dcfce7'}"
                                stroke="${element.strokeColor || '#10b981'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(mathTriSize + 20) / 2}" y="${mathTriSize + 25}" text-anchor="middle" font-size="10" fill="#064e3b">Math Triangle</text>
                    </svg>`;
                case 'math-square':
                    const mathSquareSize = element.shapeSize || 80;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathSquareSize + 20} ${mathSquareSize + 30}" style="border: 2px solid #10b981; background: #f0fdf4; border-radius: 8px;">
                        <rect x="10" y="10" width="${mathSquareSize}" height="${mathSquareSize}"
                              fill="${element.fillColor || '#dcfce7'}"
                              stroke="${element.strokeColor || '#10b981'}"
                              stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(mathSquareSize + 20) / 2}" y="${mathSquareSize + 25}" text-anchor="middle" font-size="10" fill="#064e3b">Math Square</text>
                    </svg>`;
                case 'math-circle':
                    const mathCircleRadius = (element.shapeSize || 80) / 2;
                    const mathCircleDiameter = mathCircleRadius * 2;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathCircleDiameter + 20} ${mathCircleDiameter + 30}" style="border: 2px solid #10b981; background: #f0fdf4; border-radius: 8px;">
                        <circle cx="${(mathCircleDiameter + 20) / 2}" cy="${mathCircleRadius + 10}" r="${mathCircleRadius}"
                               fill="${element.fillColor || '#dcfce7'}"
                               stroke="${element.strokeColor || '#10b981'}"
                               stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(mathCircleDiameter + 20) / 2}" y="${mathCircleDiameter + 25}" text-anchor="middle" font-size="10" fill="#064e3b">Math Circle</text>
                    </svg>`;
                case 'math-rectangle':
                    const mathRectWidth = element.shapeWidth || 100;
                    const mathRectHeight = element.shapeHeight || 60;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathRectWidth + 20} ${mathRectHeight + 30}" style="border: 2px solid #10b981; background: #f0fdf4; border-radius: 8px;">
                        <rect x="10" y="10" width="${mathRectWidth}" height="${mathRectHeight}"
                              fill="${element.fillColor || '#dcfce7'}"
                              stroke="${element.strokeColor || '#10b981'}"
                              stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(mathRectWidth + 20) / 2}" y="${mathRectHeight + 25}" text-anchor="middle" font-size="10" fill="#064e3b">Math Rectangle</text>
                    </svg>`;
                case 'math-polygon':
                    const mathPolySize = element.shapeSize || 80;
                    const mathPolySides = element.sides || 6;
                    const mathPolyViewBox = `0 0 ${mathPolySize + 20} ${mathPolySize + 30}`;
                    const mathPolyCenterX = (mathPolySize + 20) / 2;
                    const mathPolyCenterY = (mathPolySize + 20) / 2;
                    const mathPolyRadius = mathPolySize / 2;
                    const mathPolyPoints = [];
                    for (let i = 0; i < mathPolySides; i++) {
                        const angle = (i * 2 * Math.PI / mathPolySides) - (Math.PI / 2);
                        const x = mathPolyCenterX + mathPolyRadius * Math.cos(angle);
                        const y = mathPolyCenterY + mathPolyRadius * Math.sin(angle);
                        mathPolyPoints.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                    }
                    return `<svg width="100%" height="100%" viewBox="${mathPolyViewBox}" style="border: 2px solid #10b981; background: #f0fdf4; border-radius: 8px;">
                        <polygon points="${mathPolyPoints.join(' ')}"
                                fill="${element.fillColor || '#dcfce7'}"
                                stroke="${element.strokeColor || '#10b981'}"
                                stroke-width="${element.strokeWidth || 2}" />
                        <text x="${mathPolyCenterX}" y="${mathPolySize + 25}" text-anchor="middle" font-size="10" fill="#064e3b">Math Polygon (${mathPolySides} sides)</text>
                    </svg>`;

                // Math Elements - 3D Shapes
                case 'math-cube':
                    const mathCubeSize = element.shapeSize || 80;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathCubeSize + 40} ${mathCubeSize + 50}" style="border: 2px solid #f59e0b; background: #fffbeb; border-radius: 8px;">
                        <g transform="translate(10, 10)">
                            <!-- Front face -->
                            <rect x="0" y="20" width="${mathCubeSize}" height="${mathCubeSize}" fill="${element.fillColor || '#fef3c7'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                            <!-- Top face -->
                            <polygon points="0,20 20,0 ${mathCubeSize + 20},0 ${mathCubeSize},20" fill="${element.fillColor || '#fde68a'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                            <!-- Right face -->
                            <polygon points="${mathCubeSize},20 ${mathCubeSize + 20},0 ${mathCubeSize + 20},${mathCubeSize} ${mathCubeSize},${mathCubeSize + 20}" fill="${element.fillColor || '#fcd34d'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        </g>
                        <text x="${(mathCubeSize + 40) / 2}" y="${mathCubeSize + 35}" text-anchor="middle" font-size="10" fill="#92400e">Math Cube</text>
                    </svg>`;
                case 'math-sphere':
                    const mathSphereRadius = (element.shapeSize || 80) / 2;
                    const mathSphereDiameter = mathSphereRadius * 2;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathSphereDiameter + 20} ${mathSphereDiameter + 30}" style="border: 2px solid #f59e0b; background: #fffbeb; border-radius: 8px;">
                        <defs>
                            <radialGradient id="sphereGradient" cx="30%" cy="30%">
                                <stop offset="0%" style="stop-color:#fef3c7;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#f59e0b;stop-opacity:1" />
                            </radialGradient>
                        </defs>
                        <circle cx="${(mathSphereDiameter + 20) / 2}" cy="${mathSphereRadius + 10}" r="${mathSphereRadius}"
                               fill="url(#sphereGradient)"
                               stroke="${element.strokeColor || '#f59e0b'}"
                               stroke-width="${element.strokeWidth || 2}" />
                        <text x="${(mathSphereDiameter + 20) / 2}" y="${mathSphereDiameter + 25}" text-anchor="middle" font-size="10" fill="#92400e">Math Sphere</text>
                    </svg>`;
                case 'math-cylinder':
                    const mathCylWidth = element.shapeWidth || 80;
                    const mathCylHeight = element.shapeHeight || 100;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathCylWidth + 20} ${mathCylHeight + 30}" style="border: 2px solid #f59e0b; background: #fffbeb; border-radius: 8px;">
                        <defs>
                            <ellipse id="cylTop" cx="${(mathCylWidth + 20) / 2}" cy="15" rx="${mathCylWidth / 2}" ry="10"/>
                        </defs>
                        <!-- Cylinder body -->
                        <rect x="${10 + (mathCylWidth / 4)}" y="15" width="${mathCylWidth / 2}" height="${mathCylHeight}" fill="${element.fillColor || '#fef3c7'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        <!-- Top ellipse -->
                        <use href="#cylTop" fill="${element.fillColor || '#fde68a'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        <!-- Bottom ellipse -->
                        <ellipse cx="${(mathCylWidth + 20) / 2}" cy="${mathCylHeight + 15}" rx="${mathCylWidth / 2}" ry="10" fill="${element.fillColor || '#fcd34d'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        <text x="${(mathCylWidth + 20) / 2}" y="${mathCylHeight + 35}" text-anchor="middle" font-size="10" fill="#92400e">Math Cylinder</text>
                    </svg>`;
                case 'math-cone':
                    const mathConeBase = element.shapeWidth || 80;
                    const mathConeHeight = element.shapeHeight || 100;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathConeBase + 20} ${mathConeHeight + 30}" style="border: 2px solid #f59e0b; background: #fffbeb; border-radius: 8px;">
                        <!-- Cone body -->
                        <polygon points="${(mathConeBase + 20) / 2},10 10,${mathConeHeight} ${mathConeBase + 10},${mathConeHeight}" fill="${element.fillColor || '#fef3c7'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        <!-- Base ellipse -->
                        <ellipse cx="${(mathConeBase + 20) / 2}" cy="${mathConeHeight}" rx="${mathConeBase / 2}" ry="8" fill="${element.fillColor || '#fcd34d'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        <text x="${(mathConeBase + 20) / 2}" y="${mathConeHeight + 25}" text-anchor="middle" font-size="10" fill="#92400e">Math Cone</text>
                    </svg>`;
                case 'math-pyramid':
                    const mathPyramidBase = element.shapeWidth || 80;
                    const mathPyramidHeight = element.shapeHeight || 80;
                    return `<svg width="100%" height="100%" viewBox="0 0 ${mathPyramidBase + 40} ${mathPyramidHeight + 30}" style="border: 2px solid #f59e0b; background: #fffbeb; border-radius: 8px;">
                        <!-- Pyramid faces -->
                        <polygon points="${(mathPyramidBase + 40) / 2},10 10,${mathPyramidHeight + 10} ${mathPyramidBase + 10},${mathPyramidHeight + 10}" fill="${element.fillColor || '#fef3c7'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        <polygon points="${(mathPyramidBase + 40) / 2},10 ${mathPyramidBase + 10},${mathPyramidHeight + 10} ${mathPyramidBase + 30},${mathPyramidHeight + 10}" fill="${element.fillColor || '#fde68a'}" stroke="${element.strokeColor || '#f59e0b'}" stroke-width="2"/>
                        <text x="${(mathPyramidBase + 40) / 2}" y="${mathPyramidHeight + 25}" text-anchor="middle" font-size="10" fill="#92400e">Math Pyramid</text>
                    </svg>`;

                // Math Elements - Charts and Graphs
                case 'math-bar-chart':
                    const barChartData = element.chartData || 'A:10, B:20, C:15, D:25';
                    const barChartTitle = element.chartTitle || 'Math Bar Chart';
                    const barChartColor = element.chartColor || '#ef4444';

                    // Parse chart data
                    const barData = barChartData.split(',').map(item => {
                        const [label, value] = item.split(':').map(s => s.trim());
                        return { label, value: parseFloat(value) || 0 };
                    });

                    const maxValue = Math.max(...barData.map(d => d.value));
                    const barWidth = Math.min(40, 200 / barData.length);

                    const barsHTML = barData.map((data, index) => {
                        const height = (data.value / maxValue) * 80;
                        const x = index * (barWidth + 5) + 10;
                        return `
                            <rect x="${x}" y="${100 - height}" width="${barWidth}" height="${height}"
                                  fill="${barChartColor}" opacity="${0.7 + (index * 0.1)}" rx="2"/>
                            <text x="${x + barWidth/2}" y="115" text-anchor="middle" font-size="8" fill="#374151">${data.label}</text>
                            <text x="${x + barWidth/2}" y="${95 - height}" text-anchor="middle" font-size="8" fill="#374151">${data.value}</text>
                        `;
                    }).join('');

                    return `<div style="padding: 15px; background: #fef2f2; border: 2px solid #ef4444; border-radius: 8px;">
                        <div style="text-align: center; margin-bottom: 10px; font-weight: bold; color: #7f1d1d;">${barChartTitle}</div>
                        <svg width="100%" height="130" viewBox="0 0 ${Math.max(200, barData.length * (barWidth + 5) + 20)} 130" style="background: white; border-radius: 4px;">
                            ${barsHTML}
                        </svg>
                        <small style="color: #7f1d1d; text-align: center; display: block;">Math Bar Chart (${barData.length} bars)</small>
                    </div>`;
                case 'math-line-graph':
                    const lineChartData = element.chartData || 'Jan:10, Feb:20, Mar:15, Apr:25, May:30';
                    const lineChartTitle = element.chartTitle || 'Math Line Graph';
                    const lineChartColor = element.chartColor || '#ef4444';

                    // Parse chart data
                    const lineData = lineChartData.split(',').map(item => {
                        const [label, value] = item.split(':').map(s => s.trim());
                        return { label, value: parseFloat(value) || 0 };
                    });

                    const maxLineValue = Math.max(...lineData.map(d => d.value));
                    const stepX = 160 / (lineData.length - 1);

                    const points = lineData.map((data, index) => {
                        const x = 20 + (index * stepX);
                        const y = 90 - ((data.value / maxLineValue) * 60);
                        return `${x},${y}`;
                    }).join(' ');

                    const circles = lineData.map((data, index) => {
                        const x = 20 + (index * stepX);
                        const y = 90 - ((data.value / maxLineValue) * 60);
                        return `<circle cx="${x}" cy="${y}" r="3" fill="${lineChartColor}"/>`;
                    }).join('');

                    const labels = lineData.map((data, index) => {
                        const x = 20 + (index * stepX);
                        return `<text x="${x}" y="110" text-anchor="middle" font-size="8" fill="#374151">${data.label}</text>`;
                    }).join('');

                    return `<div style="padding: 15px; background: #fef2f2; border: 2px solid #ef4444; border-radius: 8px;">
                        <div style="text-align: center; margin-bottom: 10px; font-weight: bold; color: #7f1d1d;">${lineChartTitle}</div>
                        <svg width="100%" height="120" viewBox="0 0 200 120" style="background: white; border-radius: 4px;">
                            <polyline points="${points}" stroke="${lineChartColor}" stroke-width="2" fill="none"/>
                            ${circles}
                            ${labels}
                        </svg>
                        <small style="color: #7f1d1d; text-align: center; display: block;">Math Line Graph (${lineData.length} points)</small>
                    </div>`;
                case 'math-pie-chart':
                    return `<div style="padding: 15px; background: #fef2f2; border: 2px solid #ef4444; border-radius: 8px; text-align: center;">
                        <svg width="120" height="120" viewBox="0 0 120 120">
                            <circle cx="60" cy="60" r="50" fill="#fca5a5"/>
                            <path d="M 60,60 L 60,10 A 50,50 0 0,1 95,35 z" fill="#f87171"/>
                            <path d="M 60,60 L 95,35 A 50,50 0 0,1 95,85 z" fill="#ef4444"/>
                            <path d="M 60,60 L 95,85 A 50,50 0 0,1 60,110 z" fill="#dc2626"/>
                        </svg>
                        <br><small style="color: #7f1d1d;">Math Pie Chart</small>
                    </div>`;

                case 'math-coordinate-grid':
                    return `<div style="padding: 15px; background: #fef2f2; border: 2px solid #ef4444; border-radius: 8px;">
                        <svg width="100%" height="160" viewBox="0 0 200 160" style="background: white; border-radius: 4px;">
                            <!-- Grid lines -->
                            <defs>
                                <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                                    <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e5e7eb" stroke-width="1"/>
                                </pattern>
                            </defs>
                            <rect width="200" height="160" fill="url(#grid)"/>
                            <!-- Axes -->
                            <line x1="100" y1="0" x2="100" y2="160" stroke="#374151" stroke-width="2"/>
                            <line x1="0" y1="80" x2="200" y2="80" stroke="#374151" stroke-width="2"/>
                            <!-- Axis labels -->
                            <text x="190" y="75" font-size="12" fill="#374151">x</text>
                            <text x="105" y="15" font-size="12" fill="#374151">y</text>
                        </svg>
                        <small style="color: #7f1d1d; text-align: center; display: block;">Math Coordinate Grid</small>
                    </div>`;
                case 'math-scatter-plot':
                    // Parse scatter plot data
                    const scatterData = element.scatterData || [
                        {x: 1, y: 4}, {x: 2, y: 3}, {x: 3, y: 4.5}, {x: 4, y: 2},
                        {x: 5, y: 3.5}, {x: 6, y: 1.5}, {x: 7, y: 2.5}, {x: 8, y: 1}
                    ];
                    const maxX = Math.max(...scatterData.map(d => d.x));
                    const maxY = Math.max(...scatterData.map(d => d.y));
                    const scaleX = 160 / maxX;
                    const scaleY = 80 / maxY;

                    const scatterPoints = scatterData.map(point => {
                        const x = 20 + (point.x * scaleX);
                        const y = 100 - (point.y * scaleY);
                        return `<circle cx="${x}" cy="${y}" r="3" fill="#ef4444"/>`;
                    }).join('');

                    return `<div style="padding: 15px; background: #fef2f2; border: 2px solid #ef4444; border-radius: 8px;">
                        <svg width="100%" height="120" viewBox="0 0 200 120" style="background: white; border-radius: 4px;">
                            <!-- Grid lines -->
                            <defs>
                                <pattern id="scatterGrid" width="20" height="20" patternUnits="userSpaceOnUse">
                                    <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#f3f4f6" stroke-width="1"/>
                                </pattern>
                            </defs>
                            <rect width="200" height="120" fill="url(#scatterGrid)"/>
                            <!-- Axes -->
                            <line x1="20" y1="100" x2="180" y2="100" stroke="#374151" stroke-width="1"/>
                            <line x1="20" y1="20" x2="20" y2="100" stroke="#374151" stroke-width="1"/>
                            <!-- Scatter points -->
                            ${scatterPoints}
                            <!-- Axis labels -->
                            <text x="190" y="105" font-size="10" fill="#374151">x</text>
                            <text x="15" y="15" font-size="10" fill="#374151">y</text>
                        </svg>
                        <small style="color: #7f1d1d; text-align: center; display: block;">Math Scatter Plot (${scatterData.length} points)</small>
                    </div>`;

                // Math Elements - Math Science
                case 'math-measurement':
                    return `<div style="padding: 15px; background: #f3e8ff; border: 2px solid #8b5cf6; border-radius: 8px;">
                        <div style="display: flex; align-items: center; justify-content: center; height: 80px;">
                            <div style="position: relative; width: 120px; height: 20px; background: #e9d5ff; border: 2px solid #8b5cf6; border-radius: 4px;">
                                <div style="position: absolute; top: -15px; left: 0; font-size: 10px; color: #581c87;">0</div>
                                <div style="position: absolute; top: -15px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #581c87;">5</div>
                                <div style="position: absolute; top: -15px; right: 0; font-size: 10px; color: #581c87;">10</div>
                                <div style="position: absolute; top: 25px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #581c87;">cm</div>
                            </div>
                        </div>
                        <small style="color: #581c87; text-align: center; display: block;">Math Measurement</small>
                    </div>`;
                case 'math-angle':
                    return `<div style="padding: 15px; background: #f3e8ff; border: 2px solid #8b5cf6; border-radius: 8px; text-align: center;">
                        <svg width="120" height="100" viewBox="0 0 120 100">
                            <!-- Angle lines -->
                            <line x1="20" y1="80" x2="100" y2="80" stroke="#8b5cf6" stroke-width="3"/>
                            <line x1="20" y1="80" x2="80" y2="20" stroke="#8b5cf6" stroke-width="3"/>
                            <!-- Angle arc -->
                            <path d="M 40,80 A 20,20 0 0,0 35,65" stroke="#a855f7" stroke-width="2" fill="none"/>
                            <!-- Angle label -->
                            <text x="45" y="75" font-size="12" fill="#581c87">45</text>
                        </svg>
                        <small style="color: #581c87;">Math Angle</small>
                    </div>`;
                case 'math-vector':
                    return `<div style="padding: 15px; background: #f3e8ff; border: 2px solid #8b5cf6; border-radius: 8px; text-align: center;">
                        <svg width="120" height="100" viewBox="0 0 120 100">
                            <!-- Vector arrow -->
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#8b5cf6"/>
                                </marker>
                            </defs>
                            <line x1="20" y1="80" x2="90" y2="30" stroke="#8b5cf6" stroke-width="3" marker-end="url(#arrowhead)"/>
                            <!-- Vector label -->
                            <text x="60" y="60" font-size="12" fill="#581c87" font-weight="bold">v</text>
                        </svg>
                        <small style="color: #581c87;">Math Vector</small>
                    </div>`;
                case 'math-matrix':
                    const matrixRows = element.matrixRows || 2;
                    const matrixCols = element.matrixCols || 2;
                    const matrixValues = element.matrixValues || '1,2;3,4';

                    // Parse matrix values
                    const rows = matrixValues.split(';');
                    let matrixHTML = '<table style="border-collapse: collapse;">';

                    for (let i = 0; i < matrixRows; i++) {
                        matrixHTML += '<tr>';
                        const rowValues = rows[i] ? rows[i].split(',') : [];
                        for (let j = 0; j < matrixCols; j++) {
                            const value = rowValues[j] || (i * matrixCols + j + 1);
                            matrixHTML += `<td contenteditable="true" style="padding: 5px 10px; text-align: center; font-weight: bold; color: #581c87; min-width: 30px;">${value}</td>`;
                        }
                        matrixHTML += '</tr>';
                    }
                    matrixHTML += '</table>';

                    return `<div style="padding: 15px; background: #f3e8ff; border: 2px solid #8b5cf6; border-radius: 8px; text-align: center;">
                        <div style="display: inline-block; border-left: 3px solid #8b5cf6; border-right: 3px solid #8b5cf6; padding: 10px 15px;">
                            ${matrixHTML}
                        </div>
                        <br><small style="color: #581c87;">Math Matrix (${matrixRows}${matrixCols})</small>
                    </div>`;

                default:
                    return `<div style="padding: 15px; text-align: center; color: #64748b;">
                        <i class="fas fa-cube fa-2x mb-2"></i><br>
                        ${element.type.replace('-', ' ').toUpperCase()}
                    </div>`;
            }
        }

        // Make element draggable within canvas
        function makeDraggable(element) {
            if (!element) {
                console.warn('Cannot make null element draggable');
                return;
            }

            let isDragging = false;
            let startX, startY, initialX, initialY;

            try {
                element.addEventListener('mousedown', function(e) {
                // Don't drag if clicking on contenteditable elements, buttons, or inputs
                if (e.target.contentEditable === 'true' ||
                    e.target.tagName === 'BUTTON' ||
                    e.target.tagName === 'INPUT' ||
                    e.target.tagName === 'TEXTAREA' ||
                    e.target.closest('button') ||
                    e.target.closest('[contenteditable="true"]')) {
                    return;
                }

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(element.style.left);
                initialY = parseInt(element.style.top);

                element.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                element.style.left = (initialX + deltaX) + 'px';
                element.style.top = (initialY + deltaY) + 'px';
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    element.style.cursor = 'move';

                    // Update element data
                    const elementData = quizElements.find(e => e.id === element.id);
                    if (elementData) {
                        elementData.x = parseInt(element.style.left);
                        elementData.y = parseInt(element.style.top);
                    }
                }
            });
            } catch (error) {
                console.error('Error making element draggable:', error);
            }
        }

        // Select element
        function selectElement(elementId) {
            deselectAllElements();

            const element = document.getElementById(elementId);
            if (element) {
                element.classList.add('selected');
                selectedElement = elementId;
                showElementProperties(elementId);
            }
        }

        // Deselect all elements
        function deselectAllElements() {
            document.querySelectorAll('.canvas-element').forEach(el => {
                el.classList.remove('selected');
            });
            selectedElement = null;
            showDefaultProperties();
        }

        // Show element properties
        function showElementProperties(elementId) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (!elementData) return;

            const propertiesContent = document.getElementById('properties-content');
            propertiesContent.innerHTML = `
                <div class="property-group">
                    <label>Element Type</label>
                    <input type="text" value="${elementData.type}" readonly class="form-control">
                </div>
                <div class="property-group">
                    <label>Width (px)</label>
                    <input type="number" value="${elementData.width}" onchange="updateElementProperty('${elementId}', 'width', this.value + 'px')" class="form-control">
                </div>
                <div class="property-group">
                    <label>Height (px)</label>
                    <input type="number" value="${elementData.height}" onchange="updateElementProperty('${elementId}', 'height', this.value + 'px')" class="form-control">
                </div>
                <div class="property-group">
                    <label>Background Color</label>
                    <input type="color" value="${elementData.style.backgroundColor}" onchange="updateElementStyle('${elementId}', 'backgroundColor', this.value)" class="form-control">
                </div>
                <div class="property-group">
                    <label>Border Color</label>
                    <input type="color" value="${elementData.style.border.split(' ')[2] || '#e2e8f0'}" onchange="updateElementStyle('${elementId}', 'border', '1px solid ' + this.value)" class="form-control">
                </div>
                <div class="property-group">
                    <label>Font Size</label>
                    <select onchange="updateElementStyle('${elementId}', 'fontSize', this.value)" class="form-control">
                        <option value="12px" ${elementData.style.fontSize === '12px' ? 'selected' : ''}>12px</option>
                        <option value="14px" ${elementData.style.fontSize === '14px' ? 'selected' : ''}>14px</option>
                        <option value="16px" ${elementData.style.fontSize === '16px' ? 'selected' : ''}>16px</option>
                        <option value="18px" ${elementData.style.fontSize === '18px' ? 'selected' : ''}>18px</option>
                        <option value="20px" ${elementData.style.fontSize === '20px' ? 'selected' : ''}>20px</option>
                        <option value="24px" ${elementData.style.fontSize === '24px' ? 'selected' : ''}>24px</option>
                    </select>
                </div>
                ${getTypeSpecificProperties(elementData)}
            `;
        }

        // Get type-specific properties
        function getTypeSpecificProperties(elementData) {
            switch(elementData.type) {
                case 'latex':
                    return `
                        <div class="property-group">
                            <label>LaTeX Expression</label>
                            <textarea onchange="updateLatexContent('${elementData.id}', this.value)" class="form-control" rows="3" placeholder="Enter LaTeX expression...">${elementData.content || 'x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}'}</textarea>
                            <small class="text-muted">Use LaTeX syntax (e.g., \\frac{a}{b}, \\sqrt{x}, x^2)</small>
                        </div>
                    `;
                case 'image':
                    return `
                        <div class="property-group">
                            <label>Image Upload</label>
                            <button type="button" class="btn btn-primary btn-sm w-100" onclick="triggerImageUpload('${elementData.id}')">
                                <i class="fas fa-upload me-1"></i>Choose Image
                            </button>
                            <small class="text-muted">Supported formats: JPG, PNG, GIF (max 5MB)</small>
                        </div>
                        ${elementData.content && elementData.content.startsWith('data:image') ? `
                        <div class="property-group">
                            <label>Image Fit</label>
                            <select onchange="updateImageProperty('${elementData.id}', 'objectFit', this.value)" class="form-control">
                                <option value="contain" ${(elementData.objectFit || 'contain') === 'contain' ? 'selected' : ''}>Fit to Container</option>
                                <option value="cover" ${elementData.objectFit === 'cover' ? 'selected' : ''}>Fill Container</option>
                                <option value="fill" ${elementData.objectFit === 'fill' ? 'selected' : ''}>Stretch to Fill</option>
                                <option value="scale-down" ${elementData.objectFit === 'scale-down' ? 'selected' : ''}>Scale Down</option>
                                <option value="none" ${elementData.objectFit === 'none' ? 'selected' : ''}>Original Size</option>
                            </select>
                            <small class="text-muted">How the image should fit within the container</small>
                        </div>
                        <div class="property-group">
                            <label>Image Position</label>
                            <select onchange="updateImageProperty('${elementData.id}', 'objectPosition', this.value)" class="form-control">
                                <option value="center" ${(elementData.objectPosition || 'center') === 'center' ? 'selected' : ''}>Center</option>
                                <option value="top" ${elementData.objectPosition === 'top' ? 'selected' : ''}>Top</option>
                                <option value="bottom" ${elementData.objectPosition === 'bottom' ? 'selected' : ''}>Bottom</option>
                                <option value="left" ${elementData.objectPosition === 'left' ? 'selected' : ''}>Left</option>
                                <option value="right" ${elementData.objectPosition === 'right' ? 'selected' : ''}>Right</option>
                                <option value="top left" ${elementData.objectPosition === 'top left' ? 'selected' : ''}>Top Left</option>
                                <option value="top right" ${elementData.objectPosition === 'top right' ? 'selected' : ''}>Top Right</option>
                                <option value="bottom left" ${elementData.objectPosition === 'bottom left' ? 'selected' : ''}>Bottom Left</option>
                                <option value="bottom right" ${elementData.objectPosition === 'bottom right' ? 'selected' : ''}>Bottom Right</option>
                            </select>
                            <small class="text-muted">Position of the image within the container</small>
                        </div>
                        ` : ''}
                    `;
                case 'table':
                    return `
                        <div class="property-group">
                            <label>Table Actions</label>
                            <div class="btn-group w-100 mb-2" role="group">
                                <button type="button" class="btn btn-outline-primary btn-sm" onclick="addTableRow('${elementData.id}')">
                                    <i class="fas fa-plus"></i> Row
                                </button>
                                <button type="button" class="btn btn-outline-primary btn-sm" onclick="addTableColumn('${elementData.id}')">
                                    <i class="fas fa-plus"></i> Column
                                </button>
                            </div>
                            <div class="btn-group w-100" role="group">
                                <button type="button" class="btn btn-outline-danger btn-sm" onclick="removeTableRow('${elementData.id}')">
                                    <i class="fas fa-minus"></i> Row
                                </button>
                                <button type="button" class="btn btn-outline-danger btn-sm" onclick="removeTableColumn('${elementData.id}')">
                                    <i class="fas fa-minus"></i> Column
                                </button>
                            </div>
                        </div>
                    `;

                // Shape properties
                case 'line':
                    return `
                        <div class="property-group">
                            <label>Length (px)</label>
                            <input type="number" min="10" max="500" value="${elementData.shapeLength || 180}" onchange="updateShapeDimension('${elementData.id}', 'shapeLength', this.value)" class="form-control">
                            <small class="text-muted">Length of the line</small>
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                        <div class="property-group">
                            <label>Line Style</label>
                            <select onchange="updateShapeProperty('${elementData.id}', 'strokeDasharray', this.value)" class="form-control">
                                <option value="" ${!elementData.strokeDasharray ? 'selected' : ''}>Solid</option>
                                <option value="5,5" ${elementData.strokeDasharray === '5,5' ? 'selected' : ''}>Dashed</option>
                                <option value="2,2" ${elementData.strokeDasharray === '2,2' ? 'selected' : ''}>Dotted</option>
                                <option value="10,5,2,5" ${elementData.strokeDasharray === '10,5,2,5' ? 'selected' : ''}>Dash-Dot</option>
                            </select>
                        </div>
                    `;

                case 'circle':
                    return `
                        <div class="property-group">
                            <label>Diameter (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeDiameter || 100}" onchange="updateShapeDimension('${elementData.id}', 'shapeDiameter', this.value)" class="form-control">
                            <small class="text-muted">Diameter of the circle</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'square':
                    return `
                        <div class="property-group">
                            <label>Side Length (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeSideLength || 100}" onchange="updateShapeDimension('${elementData.id}', 'shapeSideLength', this.value)" class="form-control">
                            <small class="text-muted">Length of each side</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'rectangle':
                    return `
                        <div class="property-group">
                            <label>Width (px)</label>
                            <input type="number" min="30" max="400" value="${elementData.shapeWidth || 160}" onchange="updateShapeDimension('${elementData.id}', 'shapeWidth', this.value)" class="form-control">
                            <small class="text-muted">Width of the rectangle</small>
                        </div>
                        <div class="property-group">
                            <label>Height (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeHeight || 100}" onchange="updateShapeDimension('${elementData.id}', 'shapeHeight', this.value)" class="form-control">
                            <small class="text-muted">Height of the rectangle</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'rhombus':
                    return `
                        <div class="property-group">
                            <label>Width (px)</label>
                            <input type="number" min="30" max="400" value="${elementData.shapeWidth || 140}" onchange="updateShapeDimension('${elementData.id}', 'shapeWidth', this.value)" class="form-control">
                            <small class="text-muted">Width of the rhombus</small>
                        </div>
                        <div class="property-group">
                            <label>Height (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeHeight || 100}" onchange="updateShapeDimension('${elementData.id}', 'shapeHeight', this.value)" class="form-control">
                            <small class="text-muted">Height of the rhombus</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'triangle':
                    return `
                        <div class="property-group">
                            <label>Base Width (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeBaseWidth || 110}" onchange="updateShapeDimension('${elementData.id}', 'shapeBaseWidth', this.value)" class="form-control">
                            <small class="text-muted">Width of the triangle base</small>
                        </div>
                        <div class="property-group">
                            <label>Height (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeHeight || 110}" onchange="updateShapeDimension('${elementData.id}', 'shapeHeight', this.value)" class="form-control">
                            <small class="text-muted">Height of the triangle</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'parallelogram':
                    return `
                        <div class="property-group">
                            <label>Width (px)</label>
                            <input type="number" min="30" max="400" value="${elementData.shapeWidth || 160}" onchange="updateShapeDimension('${elementData.id}', 'shapeWidth', this.value)" class="form-control">
                            <small class="text-muted">Width of the parallelogram</small>
                        </div>
                        <div class="property-group">
                            <label>Height (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeHeight || 80}" onchange="updateShapeDimension('${elementData.id}', 'shapeHeight', this.value)" class="form-control">
                            <small class="text-muted">Height of the parallelogram</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'pentagon':
                case 'hexagon':
                    return `
                        <div class="property-group">
                            <label>Size (px)</label>
                            <input type="number" min="30" max="300" value="${elementData.shapeSize || 90}" onchange="updateShapeDimension('${elementData.id}', 'shapeSize', this.value)" class="form-control">
                            <small class="text-muted">Size of the ${elementData.type}</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'cube':
                case 'sphere':
                    return `
                        <div class="property-group">
                            <label>${elementData.type === 'cube' ? 'Side Length' : 'Diameter'} (px)</label>
                            <input type="number" min="30" max="300" value="${elementData.shapeSize || 80}" onchange="updateShapeDimension('${elementData.id}', 'shapeSize', this.value)" class="form-control">
                            <small class="text-muted">${elementData.type === 'cube' ? 'Length of each side' : 'Diameter of the sphere'}</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                case 'cuboid':
                    return `
                        <div class="property-group">
                            <label>Width (px)</label>
                            <input type="number" min="30" max="400" value="${elementData.shapeWidth || 120}" onchange="updateShapeDimension('${elementData.id}', 'shapeWidth', this.value)" class="form-control">
                            <small class="text-muted">Width of the cuboid</small>
                        </div>
                        <div class="property-group">
                            <label>Height (px)</label>
                            <input type="number" min="20" max="300" value="${elementData.shapeHeight || 80}" onchange="updateShapeDimension('${elementData.id}', 'shapeHeight', this.value)" class="form-control">
                            <small class="text-muted">Height of the cuboid</small>
                        </div>
                        <div class="property-group">
                            <label>Depth (px)</label>
                            <input type="number" min="10" max="200" value="${elementData.shapeDepth || 60}" onchange="updateShapeDimension('${elementData.id}', 'shapeDepth', this.value)" class="form-control">
                            <small class="text-muted">Depth of the cuboid</small>
                        </div>
                        <div class="property-group">
                            <label>Fill Color</label>
                            <input type="color" value="${elementData.fillColor || '#dbeafe'}" onchange="updateShapeProperty('${elementData.id}', 'fillColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Color</label>
                            <input type="color" value="${elementData.strokeColor || '#3b82f6'}" onchange="updateShapeProperty('${elementData.id}', 'strokeColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Stroke Width</label>
                            <input type="range" min="1" max="10" value="${elementData.strokeWidth || 2}" onchange="updateShapeProperty('${elementData.id}', 'strokeWidth', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.strokeWidth || 2}px</small>
                        </div>
                    `;

                // Chart properties
                case 'bar-chart':
                case 'line-chart':
                case 'pie-chart':
                    return `
                        <div class="property-group">
                            <label>Chart Title</label>
                            <input type="text" value="${elementData.chartTitle || 'Sample Chart'}" onchange="updateChartProperty('${elementData.id}', 'chartTitle', this.value)" class="form-control">
                            <small class="text-muted">Title displayed above the chart</small>
                        </div>
                        <div class="property-group">
                            <label>Chart Data</label>
                            <textarea rows="4" onchange="updateChartProperty('${elementData.id}', 'chartData', this.value)" class="form-control" placeholder="Enter data as: Label1:Value1, Label2:Value2">${elementData.chartData || (elementData.type === 'pie-chart' ? 'Red:30, Blue:25, Green:20, Yellow:25' : 'Jan:10, Feb:20, Mar:15, Apr:25, May:30')}</textarea>
                            <small class="text-muted">Format: Label1:Value1, Label2:Value2, ...</small>
                        </div>
                        ${elementData.type !== 'pie-chart' ? `
                        <div class="property-group">
                            <label>Y-Axis Label</label>
                            <input type="text" value="${elementData.yAxisLabel || 'Values'}" onchange="updateChartProperty('${elementData.id}', 'yAxisLabel', this.value)" class="form-control">
                            <small class="text-muted">Label for the Y-axis</small>
                        </div>
                        <div class="property-group">
                            <label>X-Axis Label</label>
                            <input type="text" value="${elementData.xAxisLabel || 'Categories'}" onchange="updateChartProperty('${elementData.id}', 'xAxisLabel', this.value)" class="form-control">
                            <small class="text-muted">Label for the X-axis</small>
                        </div>
                        ` : ''}
                        <div class="property-group">
                            <label>Chart Color Theme</label>
                            <select onchange="updateChartProperty('${elementData.id}', 'colorTheme', this.value)" class="form-control">
                                <option value="blue" ${(elementData.colorTheme || 'blue') === 'blue' ? 'selected' : ''}>Blue Theme</option>
                                <option value="green" ${elementData.colorTheme === 'green' ? 'selected' : ''}>Green Theme</option>
                                <option value="red" ${elementData.colorTheme === 'red' ? 'selected' : ''}>Red Theme</option>
                                <option value="purple" ${elementData.colorTheme === 'purple' ? 'selected' : ''}>Purple Theme</option>
                                <option value="rainbow" ${elementData.colorTheme === 'rainbow' ? 'selected' : ''}>Rainbow Theme</option>
                            </select>
                            <small class="text-muted">Color scheme for the chart</small>
                        </div>
                    `;

                // Math Elements Properties
                case 'math-equation':
                    return `
                        <div class="property-group">
                            <label>Equation Type</label>
                            <select onchange="updateMathProperty('${elementData.id}', 'equationType', this.value)" class="form-control">
                                <option value="simple" ${(elementData.equationType || 'simple') === 'simple' ? 'selected' : ''}>Simple Equation</option>
                                <option value="complex" ${elementData.equationType === 'complex' ? 'selected' : ''}>Complex Equation (LaTeX)</option>
                            </select>
                            <small class="text-muted">Choose equation complexity level</small>
                        </div>
                        <div class="property-group">
                            <label>${elementData.equationType === 'complex' ? 'LaTeX Expression' : 'Equation Content'}</label>
                            <textarea rows="3" onchange="updateMathProperty('${elementData.id}', 'content', this.value)" class="form-control" placeholder="${elementData.equationType === 'complex' ? 'Enter LaTeX: \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}' : 'Enter equation: x + 5 = 12'}">${elementData.content || (elementData.equationType === 'complex' ? '\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}' : 'x + 5 = 12')}</textarea>
                            <small class="text-muted">${elementData.equationType === 'complex' ? 'Use LaTeX syntax for complex math expressions' : 'Enter simple mathematical equations'}</small>
                        </div>
                    `;

                case 'math-scatter-plot':
                    const currentData = elementData.scatterData || [{x: 1, y: 4}, {x: 2, y: 3}, {x: 3, y: 4.5}, {x: 4, y: 2}, {x: 5, y: 3.5}, {x: 6, y: 1.5}, {x: 7, y: 2.5}, {x: 8, y: 1}];
                    const dataString = currentData.map(point => `${point.x},${point.y}`).join(';');
                    return `
                        <div class="property-group">
                            <label>Scatter Plot Data</label>
                            <textarea rows="4" onchange="updateScatterPlotData('${elementData.id}', this.value)" class="form-control" placeholder="Enter data as: x1,y1;x2,y2;x3,y3...">${dataString}</textarea>
                            <small class="text-muted">Format: x1,y1;x2,y2;x3,y3 (e.g., 1,4;2,3;3,4.5)</small>
                        </div>
                        <div class="property-group">
                            <label>Point Color</label>
                            <input type="color" value="${elementData.pointColor || '#ef4444'}" onchange="updateMathProperty('${elementData.id}', 'pointColor', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Point Size</label>
                            <input type="range" min="2" max="8" value="${elementData.pointSize || 3}" onchange="updateMathProperty('${elementData.id}', 'pointSize', this.value)" class="form-range">
                            <small class="text-muted">Current: ${elementData.pointSize || 3}px</small>
                        </div>
                        <div class="property-group">
                            <label>Show Grid</label>
                            <select onchange="updateMathProperty('${elementData.id}', 'showGrid', this.value)" class="form-control">
                                <option value="true" ${(elementData.showGrid !== false) ? 'selected' : ''}>Yes</option>
                                <option value="false" ${elementData.showGrid === false ? 'selected' : ''}>No</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>X-Axis Label</label>
                            <input type="text" value="${elementData.xAxisLabel || 'x'}" onchange="updateMathProperty('${elementData.id}', 'xAxisLabel', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Y-Axis Label</label>
                            <input type="text" value="${elementData.yAxisLabel || 'y'}" onchange="updateMathProperty('${elementData.id}', 'yAxisLabel', this.value)" class="form-control">
                        </div>
                    `;

                case 'math-bar-chart':
                case 'math-line-graph':
                case 'math-pie-chart':
                    return `
                        <div class="property-group">
                            <label>Chart Title</label>
                            <input type="text" value="${elementData.chartTitle || 'Math Chart'}" onchange="updateMathProperty('${elementData.id}', 'chartTitle', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Chart Data</label>
                            <textarea rows="4" onchange="updateMathChartData('${elementData.id}', this.value)" class="form-control" placeholder="Enter data as: Label1:Value1, Label2:Value2">${elementData.chartData || 'A:10, B:20, C:15, D:25'}</textarea>
                            <small class="text-muted">Format: Label1:Value1, Label2:Value2, ...</small>
                        </div>
                        <div class="property-group">
                            <label>Chart Color</label>
                            <input type="color" value="${elementData.chartColor || '#ef4444'}" onchange="updateMathProperty('${elementData.id}', 'chartColor', this.value)" class="form-control">
                        </div>
                        ${elementData.type !== 'math-pie-chart' ? `
                        <div class="property-group">
                            <label>X-Axis Label</label>
                            <input type="text" value="${elementData.xAxisLabel || 'Categories'}" onchange="updateMathProperty('${elementData.id}', 'xAxisLabel', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Y-Axis Label</label>
                            <input type="text" value="${elementData.yAxisLabel || 'Values'}" onchange="updateMathProperty('${elementData.id}', 'yAxisLabel', this.value)" class="form-control">
                        </div>
                        ` : ''}
                    `;

                case 'math-fraction':
                    return `
                        <div class="property-group">
                            <label>Numerator</label>
                            <input type="text" value="${elementData.numerator || '3'}" onchange="updateMathProperty('${elementData.id}', 'numerator', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Denominator</label>
                            <input type="text" value="${elementData.denominator || '4'}" onchange="updateMathProperty('${elementData.id}', 'denominator', this.value)" class="form-control">
                        </div>
                        <div class="property-group">
                            <label>Fraction Size</label>
                            <select onchange="updateMathProperty('${elementData.id}', 'fractionSize', this.value)" class="form-control">
                                <option value="small" ${(elementData.fractionSize || 'medium') === 'small' ? 'selected' : ''}>Small</option>
                                <option value="medium" ${(elementData.fractionSize || 'medium') === 'medium' ? 'selected' : ''}>Medium</option>
                                <option value="large" ${elementData.fractionSize === 'large' ? 'selected' : ''}>Large</option>
                            </select>
                        </div>
                    `;

                case 'math-matrix':
                    return `
                        <div class="property-group">
                            <label>Matrix Size</label>
                            <div class="row">
                                <div class="col-6">
                                    <label class="form-label">Rows</label>
                                    <input type="number" min="1" max="5" value="${elementData.matrixRows || 2}" onchange="updateMatrixSize('${elementData.id}', this.value, document.getElementById('matrix-cols-${elementData.id}').value)" class="form-control">
                                </div>
                                <div class="col-6">
                                    <label class="form-label">Columns</label>
                                    <input type="number" min="1" max="5" value="${elementData.matrixCols || 2}" id="matrix-cols-${elementData.id}" onchange="updateMatrixSize('${elementData.id}', document.querySelector('input[onchange*=\"updateMatrixSize\"]').value, this.value)" class="form-control">
                                </div>
                            </div>
                        </div>
                        <div class="property-group">
                            <label>Matrix Values</label>
                            <textarea rows="3" onchange="updateMathProperty('${elementData.id}', 'matrixValues', this.value)" class="form-control" placeholder="Enter values row by row: 1,2;3,4">${elementData.matrixValues || '1,2;3,4'}</textarea>
                            <small class="text-muted">Format: row1val1,row1val2;row2val1,row2val2</small>
                        </div>
                    `;

                default:
                    return '';
            }
        }

        // Show default properties
        function showDefaultProperties() {
            const propertiesContent = document.getElementById('properties-content');
            propertiesContent.innerHTML = `
                <div class="text-center text-muted">
                    <i class="fas fa-hand-pointer fa-2x mb-3"></i>
                    <p>Select an element to edit its properties</p>
                </div>
            `;
        }

        // Update element property
        function updateElementProperty(elementId, property, value) {
            const element = document.getElementById(elementId);
            const elementData = quizElements.find(e => e.id === elementId);

            if (element && elementData) {
                element.style[property] = value;
                elementData[property] = parseInt(value);
            }
        }

        // Update element style
        function updateElementStyle(elementId, property, value) {
            const element = document.getElementById(elementId);
            const elementData = quizElements.find(e => e.id === elementId);

            if (element && elementData) {
                element.style[property] = value;
                elementData.style[property] = value;
            }
        }

        // Update LaTeX content
        function updateLatexContent(elementId, content) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                elementData.content = content;

                // Re-render the LaTeX
                const latexDiv = document.getElementById(`latex-${elementId}`);
                if (latexDiv) {
                    latexDiv.innerHTML = `$$${content}$$`;
                    if (window.MathJax) {
                        MathJax.typesetPromise([latexDiv]);
                    }
                }
            }
        }

        // Update shape properties
        function updateShapeProperty(elementId, property, value) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                // Store the property in the element data
                elementData[property] = value;

                // Re-render the element to apply the changes
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = getElementContent(elementData);
                }

                // Update the properties panel to show current value
                if (property === 'strokeWidth') {
                    const strokeWidthDisplay = document.querySelector(`small.text-muted`);
                    if (strokeWidthDisplay && strokeWidthDisplay.textContent.includes('Current:')) {
                        strokeWidthDisplay.textContent = `Current: ${value}px`;
                    }
                }
            }
        }
        window.updateShapeProperty = updateShapeProperty;

        // Update image properties
        function updateImageProperty(elementId, property, value) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                // Store the property in the element data
                elementData[property] = value;

                // Re-render the element to apply the changes
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = getElementContent(elementData);
                }
            }
        }
        window.updateImageProperty = updateImageProperty;

        // Update shape dimensions
        function updateShapeDimension(elementId, property, value) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                // Store the dimension property in the element data
                elementData[property] = parseInt(value);

                // Re-render the element to apply the changes
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = getElementContent(elementData);
                }

                // For certain shapes, we might want to update the container size too
                if (elementData.type === 'line' && property === 'shapeLength') {
                    // Update container width for lines
                    element.style.width = (parseInt(value) + 20) + 'px';
                    elementData.width = parseInt(value) + 20;
                } else if ((elementData.type === 'circle' || elementData.type === 'square') &&
                          (property === 'shapeDiameter' || property === 'shapeSideLength')) {
                    // Update container size for circles and squares
                    const size = parseInt(value) + 20;
                    element.style.width = size + 'px';
                    element.style.height = size + 'px';
                    elementData.width = size;
                    elementData.height = size;
                }
            }
        }
        window.updateShapeDimension = updateShapeDimension;

        // Add element to canvas (for quick buttons)
        function addElementToCanvas(type) {
            try {
                // Find a good position for the new element
                const canvas = document.getElementById('canvas');
                if (!canvas) {
                    console.error('Canvas element not found!');
                    // Fallback to default position
                    createElement(type, 150, 150);
                    return;
                }

                const canvasRect = canvas.getBoundingClientRect();

                // Calculate position relative to canvas (center-ish with some randomness)
                const x = Math.max(50, Math.min(canvasRect.width - 200, 100 + Math.random() * 200));
                const y = Math.max(50, Math.min(canvasRect.height - 150, 100 + Math.random() * 150));

                // Create the element
                createElement(type, x, y);
            } catch (error) {
                console.error('Error in addElementToCanvas:', error);
                // Fallback to default position
                createElement(type, 150, 150);
            }
        }
        window.addElementToCanvas = addElementToCanvas;

        // Chart rendering functions
        function renderChart(element) {
            const canvas = document.getElementById(`chart-${element.id}`);
            if (!canvas || !window.Chart) {
                console.log('Canvas or Chart.js not available for', element.id);
                return;
            }

            // Destroy existing chart if it exists
            if (canvas.chart) {
                canvas.chart.destroy();
            }

            // Parse chart data
            const chartDataStr = element.chartData || getDefaultChartData(element.type);
            const dataPoints = parseChartData(chartDataStr);

            // Get color theme
            const colors = getChartColors(element.colorTheme || 'blue', dataPoints.length);

            // Create chart configuration
            const config = createChartConfig(element, dataPoints, colors);

            // Create the chart
            try {
                canvas.chart = new Chart(canvas, config);
                console.log('Chart created successfully for', element.id);
            } catch (error) {
                console.error('Error creating chart:', error);
            }
        }

        function getDefaultChartData(chartType) {
            switch (chartType) {
                case 'pie-chart':
                    return 'Red:30, Blue:25, Green:20, Yellow:25';
                case 'bar-chart':
                case 'line-chart':
                default:
                    return 'Jan:10, Feb:20, Mar:15, Apr:25, May:30';
            }
        }

        function parseChartData(dataStr) {
            const pairs = dataStr.split(',').map(pair => pair.trim());
            const labels = [];
            const values = [];

            pairs.forEach(pair => {
                const [label, value] = pair.split(':').map(item => item.trim());
                if (label && value && !isNaN(parseFloat(value))) {
                    labels.push(label);
                    values.push(parseFloat(value));
                }
            });

            return { labels, values };
        }

        function getChartColors(theme, count) {
            const themes = {
                blue: ['#3b82f6', '#60a5fa', '#93c5fd', '#bfdbfe', '#dbeafe'],
                green: ['#10b981', '#34d399', '#6ee7b7', '#9decf9', '#a7f3d0'],
                red: ['#ef4444', '#f87171', '#fca5a5', '#fecaca', '#fee2e2'],
                purple: ['#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe', '#ede9fe'],
                rainbow: ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899']
            };

            const colorSet = themes[theme] || themes.blue;
            const colors = [];

            for (let i = 0; i < count; i++) {
                colors.push(colorSet[i % colorSet.length]);
            }

            return colors;
        }

        function createChartConfig(element, dataPoints, colors) {
            const baseConfig = {
                data: {
                    labels: dataPoints.labels,
                    datasets: [{
                        data: dataPoints.values,
                        backgroundColor: colors,
                        borderColor: colors.map(color => color),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: !!(element.chartTitle),
                            text: element.chartTitle || '',
                            font: { size: 12 }
                        },
                        legend: {
                            display: element.type === 'pie-chart',
                            position: 'bottom',
                            labels: { font: { size: 10 } }
                        }
                    }
                }
            };

            // Chart type specific configurations
            switch (element.type) {
                case 'bar-chart':
                    return {
                        type: 'bar',
                        ...baseConfig,
                        options: {
                            ...baseConfig.options,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: !!(element.yAxisLabel),
                                        text: element.yAxisLabel || '',
                                        font: { size: 10 }
                                    },
                                    ticks: { font: { size: 9 } }
                                },
                                x: {
                                    title: {
                                        display: !!(element.xAxisLabel),
                                        text: element.xAxisLabel || '',
                                        font: { size: 10 }
                                    },
                                    ticks: { font: { size: 9 } }
                                }
                            }
                        }
                    };

                case 'line-chart':
                    return {
                        type: 'line',
                        ...baseConfig,
                        data: {
                            ...baseConfig.data,
                            datasets: [{
                                ...baseConfig.data.datasets[0],
                                fill: false,
                                tension: 0.1
                            }]
                        },
                        options: {
                            ...baseConfig.options,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: !!(element.yAxisLabel),
                                        text: element.yAxisLabel || '',
                                        font: { size: 10 }
                                    },
                                    ticks: { font: { size: 9 } }
                                },
                                x: {
                                    title: {
                                        display: !!(element.xAxisLabel),
                                        text: element.xAxisLabel || '',
                                        font: { size: 10 }
                                    },
                                    ticks: { font: { size: 9 } }
                                }
                            }
                        }
                    };

                case 'pie-chart':
                default:
                    return {
                        type: 'pie',
                        ...baseConfig
                    };
            }
        }

        // Update chart properties
        function updateChartProperty(elementId, property, value) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                // Store the property in the element data
                elementData[property] = value;

                // Re-render the chart
                setTimeout(() => renderChart(elementData), 100);
            }
        }
        window.updateChartProperty = updateChartProperty;

        // Update Math element properties
        function updateMathProperty(elementId, property, value) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                elementData[property] = value;

                // Re-render the element
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = getElementContent(elementData);

                    // If it's a complex equation, re-render MathJax
                    if (elementData.type === 'math-equation' && elementData.equationType === 'complex') {
                        if (window.MathJax) {
                            MathJax.typesetPromise([element]).catch((err) => console.log(err.message));
                        }
                    }
                }
            }
        }
        window.updateMathProperty = updateMathProperty;

        // Update scatter plot data
        function updateScatterPlotData(elementId, dataString) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                try {
                    // Parse the data string: "x1,y1;x2,y2;x3,y3"
                    const points = dataString.split(';').map(point => {
                        const [x, y] = point.split(',').map(val => parseFloat(val.trim()));
                        return { x: isNaN(x) ? 0 : x, y: isNaN(y) ? 0 : y };
                    }).filter(point => point.x !== 0 || point.y !== 0);

                    elementData.scatterData = points;

                    // Re-render the element
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.innerHTML = getElementContent(elementData);
                    }
                } catch (error) {
                    console.error('Error parsing scatter plot data:', error);
                    alert('Invalid data format. Please use: x1,y1;x2,y2;x3,y3');
                }
            }
        }
        window.updateScatterPlotData = updateScatterPlotData;

        // Update math chart data
        function updateMathChartData(elementId, dataString) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                try {
                    // Parse the data string: "Label1:Value1, Label2:Value2"
                    elementData.chartData = dataString;

                    // Re-render the element
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.innerHTML = getElementContent(elementData);
                    }
                } catch (error) {
                    console.error('Error parsing chart data:', error);
                    alert('Invalid data format. Please use: Label1:Value1, Label2:Value2');
                }
            }
        }
        window.updateMathChartData = updateMathChartData;

        // Update matrix size
        function updateMatrixSize(elementId, rows, cols) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                elementData.matrixRows = parseInt(rows);
                elementData.matrixCols = parseInt(cols);

                // Generate default matrix values if needed
                if (!elementData.matrixValues) {
                    const defaultValues = [];
                    for (let i = 0; i < rows; i++) {
                        const row = [];
                        for (let j = 0; j < cols; j++) {
                            row.push((i * parseInt(cols) + j + 1).toString());
                        }
                        defaultValues.push(row.join(','));
                    }
                    elementData.matrixValues = defaultValues.join(';');
                }

                // Re-render the element
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = getElementContent(elementData);
                }

                // Update the properties panel
                showElementProperties(elementId);
            }
        }
        window.updateMatrixSize = updateMatrixSize;

        // Trigger image upload dialog
        function triggerImageUpload(elementId) {
            console.log('Triggering image upload for element:', elementId);

            // Create a hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.style.display = 'none';

            fileInput.onchange = function(e) {
                handleImageUpload(elementId, e.target);
                document.body.removeChild(fileInput);
            };

            document.body.appendChild(fileInput);
            fileInput.click();
        }
        window.triggerImageUpload = triggerImageUpload;

        // Handle image upload
        function handleImageUpload(elementId, input) {
            const file = input.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file');
                return;
            }

            // Validate file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image file is too large. Please select an image smaller than 5MB');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const dataURL = e.target.result;

                // Validate the data URL
                if (!dataURL || !dataURL.startsWith('data:image/') || !dataURL.includes(',')) {
                    alert('Invalid image data. Please try uploading the image again.');
                    return;
                }

                // Check if data URL is reasonable size (not corrupted)
                if (dataURL.length < 100) {
                    alert('Image data appears to be corrupted. Please try uploading the image again.');
                    return;
                }

                const element = document.getElementById(elementId);
                const elementData = quizElements.find(el => el.id === elementId);

                if (element && elementData) {
                    // Update element content
                    elementData.content = dataURL;

                    // Re-render the element with the new image
                    element.innerHTML = getElementContent(elementData);

                    console.log('Image uploaded successfully for element:', elementId, 'Size:', dataURL.length, 'bytes');
                }
            };

            reader.onerror = function(error) {
                console.error('FileReader error:', error);
                alert('Error reading the image file. Please try again.');
            };

            reader.readAsDataURL(file);
        }

        // Utility function to validate and clean data URLs
        function validateAndCleanDataURLs() {
            let cleanedCount = 0;
            quizElements.forEach(element => {
                if (element.type === 'image' && element.content) {
                    if (element.content.startsWith('data:image/')) {
                        // Check if data URL is valid
                        if (!element.content.includes(',') || element.content.length < 100) {
                            console.warn('Removing invalid data URL from element:', element.id);
                            element.content = '';
                            cleanedCount++;
                        }
                    }
                }
            });

            if (cleanedCount > 0) {
                console.log(`Cleaned ${cleanedCount} invalid data URLs`);
                // Re-render all elements
                quizElements.forEach(element => {
                    const domElement = document.getElementById(element.id);
                    if (domElement) {
                        domElement.innerHTML = getElementContent(element);
                    }
                });
            }
        }
        window.validateAndCleanDataURLs = validateAndCleanDataURLs;

        // Table manipulation functions
        function addTableRow(elementId) {
            const element = document.getElementById(elementId);
            const table = element.querySelector('table');
            if (table) {
                const newRow = table.insertRow();
                const cellCount = table.rows[0].cells.length;

                for (let i = 0; i < cellCount; i++) {
                    const newCell = newRow.insertCell();
                    newCell.contentEditable = true;
                    newCell.style.cssText = 'border: 1px solid #e2e8f0; padding: 8px; outline: none;';
                    newCell.onclick = function(e) { e.stopPropagation(); };
                    newCell.textContent = 'New Cell';
                }
                console.log('Added row to table:', elementId);
            }
        }
        window.addTableRow = addTableRow;

        function addTableColumn(elementId) {
            const element = document.getElementById(elementId);
            const table = element.querySelector('table');
            if (table) {
                for (let i = 0; i < table.rows.length; i++) {
                    const newCell = table.rows[i].insertCell();
                    newCell.contentEditable = true;
                    newCell.style.cssText = 'border: 1px solid #e2e8f0; padding: 8px; outline: none;';
                    newCell.onclick = function(e) { e.stopPropagation(); };
                    newCell.textContent = 'New Cell';
                }
                console.log('Added column to table:', elementId);
            }
        }
        window.addTableColumn = addTableColumn;

        function removeTableRow(elementId) {
            const element = document.getElementById(elementId);
            const table = element.querySelector('table');
            if (table && table.rows.length > 1) {
                table.deleteRow(table.rows.length - 1);
                console.log('Removed row from table:', elementId);
            } else {
                alert('Cannot remove the last row');
            }
        }
        window.removeTableRow = removeTableRow;

        function removeTableColumn(elementId) {
            const element = document.getElementById(elementId);
            const table = element.querySelector('table');
            if (table && table.rows[0].cells.length > 1) {
                for (let i = 0; i < table.rows.length; i++) {
                    table.rows[i].deleteCell(table.rows[i].cells.length - 1);
                }
                console.log('Removed column from table:', elementId);
            } else {
                alert('Cannot remove the last column');
            }
        }
        window.removeTableColumn = removeTableColumn;

        // Delete element
        function deleteElement(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.remove();
                quizElements = quizElements.filter(e => e.id !== elementId);

                if (selectedElement === elementId) {
                    deselectAllElements();
                }

                // Show placeholder if no elements left
                if (quizElements.length === 0) {
                    document.querySelector('.canvas-placeholder').style.display = 'block';
                }
            }
        }

        // Duplicate element
        function duplicateElement(elementId) {
            const elementData = quizElements.find(e => e.id === elementId);
            if (elementData) {
                createElement(elementData.type, elementData.x + 20, elementData.y + 20);
            }
        }

        // Clear canvas
        function clearCanvas() {
            if (confirm('Are you sure you want to clear the entire canvas? This action cannot be undone.')) {
                document.querySelectorAll('.canvas-element').forEach(el => el.remove());
                quizElements = [];
                selectedElement = null;
                elementCounter = 0;
                document.querySelector('.canvas-placeholder').style.display = 'block';
                showDefaultProperties();
            }
        }
        window.clearCanvas = clearCanvas;

        // Save quiz settings
        function saveQuizSettings() {
            const title = document.getElementById('quizTitle').value;
            const grade = document.getElementById('quizGrade').value;
            const subject = document.getElementById('quizSubject').value;
            const type = document.getElementById('quizType').value;
            const description = document.getElementById('quizDescription').value;

            if (!title || !grade || !subject) {
                alert('Please fill in all required fields');
                return;
            }

            quizSettings = {
                title: title,
                description: description,
                gradeLevel: grade,
                subject: subject,
                quizType: type
            };

            // Update canvas title
            document.querySelector('.canvas-title').textContent = 'Complex Quiz Builder - ' + title;

            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('quizSettingsModal'));
            modal.hide();
        }
        window.saveQuizSettings = saveQuizSettings;

        // Open quiz settings modal
        function openQuizSettings() {
            // Show the quiz settings modal
            const modal = new bootstrap.Modal(document.getElementById('quizSettingsModal'));
            modal.show();

            // Pre-populate fields with current settings if they exist
            if (quizSettings.title) {
                document.getElementById('quizTitle').value = quizSettings.title;
            }
            if (quizSettings.grade) {
                document.getElementById('quizGrade').value = quizSettings.grade;
            }
            if (quizSettings.subject) {
                document.getElementById('quizSubject').value = quizSettings.subject;
            }
            if (quizSettings.type) {
                document.getElementById('quizType').value = quizSettings.type;
            }
            if (quizSettings.description) {
                document.getElementById('quizDescription').value = quizSettings.description;
            }
        }
        window.openQuizSettings = openQuizSettings;

        // Question Navigation System - Page-by-Page Implementation
        let currentQuestionIndex = 0;
        let questionPages = []; // Array of question page objects
        let currentPageElements = []; // Elements on current page

        // Initialize question navigation
        function initializeQuestionNavigation() {
            // Initialize with first empty page if no questions exist
            if (questionPages.length === 0) {
                createNewQuestionPage();
            }
            updateNavigationButtons();
            showCurrentQuestionPage();
        }

        // Create a new question page
        function createNewQuestionPage() {
            const newPage = {
                id: `page-${Date.now()}`,
                questionNumber: questionPages.length + 1,
                elements: [],
                title: `Question ${questionPages.length + 1}`
            };
            questionPages.push(newPage);
            return newPage;
        }

        // Update the current page elements list
        function updateCurrentPageElements() {
            if (questionPages[currentQuestionIndex]) {
                currentPageElements = questionPages[currentQuestionIndex].elements;
            } else {
                currentPageElements = [];
            }
        }

        // Auto-save current page (debounced)
        let autoSaveTimeout;
        function autoSaveCurrentPage() {
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(() => {
                console.log('Auto-saving current page...');
                saveCurrentPageElements();
            }, 1000); // Save after 1 second of inactivity
        }

        // Set up auto-save listeners on an element
        function setupAutoSaveListeners(elementDiv) {
            // Listen for input changes
            const inputs = elementDiv.querySelectorAll('input, textarea, [contenteditable]');
            inputs.forEach(input => {
                input.addEventListener('input', autoSaveCurrentPage);
                input.addEventListener('change', autoSaveCurrentPage);
                input.addEventListener('blur', autoSaveCurrentPage);
            });

            // Listen for drag end
            elementDiv.addEventListener('dragend', autoSaveCurrentPage);

            // Listen for position changes (when element is moved)
            const observer = new MutationObserver(() => {
                autoSaveCurrentPage();
            });
            observer.observe(elementDiv, {
                attributes: true,
                attributeFilter: ['style']
            });
        }

        // Navigate to next question page
        function nextQuestion() {
            console.log('=== NEXT QUESTION CLICKED ===');
            console.log('Current page:', currentQuestionIndex, 'Total pages:', questionPages.length);
            console.log('Current page elements before save:', questionPages[currentQuestionIndex]?.elements?.length || 0);

            // CRITICAL: Sync content from DOM first, then save
            syncElementsContent();
            saveCurrentPageElements();

            console.log('Current page elements after save:', questionPages[currentQuestionIndex]?.elements?.length || 0);

            if (currentQuestionIndex < questionPages.length - 1) {
                // Go to next existing page
                console.log('Going to existing next page');
                currentQuestionIndex++;
            } else {
                // Create new page
                console.log('Creating new page');
                createNewQuestionPage();
                currentQuestionIndex = questionPages.length - 1;
                console.log('New page created. Current index:', currentQuestionIndex, 'Total pages:', questionPages.length);
            }

            showCurrentQuestionPage();
            updateNavigationButtons();
            console.log('=== NEXT QUESTION COMPLETE ===');
        }

        // Navigate to previous question page
        function previousQuestion() {
            console.log('=== PREVIOUS QUESTION CLICKED ===');
            console.log('Current page:', currentQuestionIndex);

            if (currentQuestionIndex > 0) {
                // CRITICAL: Sync content from DOM first, then save
                syncElementsContent();
                saveCurrentPageElements();

                currentQuestionIndex--;
                console.log('Going to previous page:', currentQuestionIndex);
                console.log('Target page elements:', questionPages[currentQuestionIndex]?.elements?.length || 0);

                showCurrentQuestionPage();
                updateNavigationButtons();
            }
            console.log('=== PREVIOUS QUESTION COMPLETE ===');
        }

        // Save current page elements to the page object
        function saveCurrentPageElements() {
            console.log('Saving current page elements for page:', currentQuestionIndex);

            if (questionPages[currentQuestionIndex]) {
                // Get all elements currently on canvas
                const canvasElements = Array.from(document.querySelectorAll('.canvas-element')).map(el => {
                    const elementData = quizElements.find(qe => qe.id === el.id);
                    if (elementData) {
                        // Update position from DOM
                        elementData.x = parseInt(el.style.left) || elementData.x;
                        elementData.y = parseInt(el.style.top) || elementData.y;

                        // Update content based on element type
                        if (elementData.type === 'text' || elementData.type === 'textbox') {
                            const textArea = el.querySelector('textarea, .ql-editor, .text-content, [contenteditable="true"]');
                            if (textArea) {
                                elementData.content = textArea.innerHTML || textArea.value || textArea.textContent;
                            }
                        } else if (elementData.type === 'question' || elementData.type === 'sub-question') {
                            // For questions, look for the contenteditable div
                            const questionDiv = el.querySelector('[contenteditable="true"]');
                            if (questionDiv) {
                                elementData.content = questionDiv.innerHTML || questionDiv.textContent;
                                console.log('Saved question content:', elementData.content);
                            }
                        } else if (elementData.type === 'image') {
                            const img = el.querySelector('img');
                            if (img) {
                                elementData.src = img.src;
                            }
                        } else if (elementData.type === 'table') {
                            // Save table content
                            const table = el.querySelector('table');
                            if (table) {
                                elementData.tableContent = table.outerHTML;
                            }
                        } else if (elementData.type === 'latex') {
                            const latexDiv = el.querySelector('[contenteditable="true"]');
                            if (latexDiv) {
                                elementData.content = latexDiv.innerHTML || latexDiv.textContent;
                            }
                        }

                        console.log('Saved element:', elementData.id, elementData.type, elementData);
                    }
                    return elementData;
                }).filter(Boolean);

                questionPages[currentQuestionIndex].elements = canvasElements;
                console.log('Saved', canvasElements.length, 'elements to page', currentQuestionIndex);
            } else {
                console.warn('No page found at index:', currentQuestionIndex);
            }
        }

        // Show current question page
        function showCurrentQuestionPage() {
            console.log('=== SHOWING QUESTION PAGE ===');
            console.log('Page index:', currentQuestionIndex);
            console.log('Page data:', questionPages[currentQuestionIndex]);

            // Clear canvas but don't clear quizElements completely
            const canvas = document.getElementById('canvas');
            if (canvas) {
                // Remove all canvas elements from DOM
                const elements = canvas.querySelectorAll('.canvas-element');
                console.log('Removing', elements.length, 'elements from canvas');
                elements.forEach(element => element.remove());
            }

            // Clear quizElements array to avoid duplicates
            quizElements.length = 0;

            // Load elements for current page
            if (questionPages[currentQuestionIndex] && questionPages[currentQuestionIndex].elements) {
                console.log('Loading', questionPages[currentQuestionIndex].elements.length, 'elements for page', currentQuestionIndex);

                questionPages[currentQuestionIndex].elements.forEach((element, index) => {
                    console.log(`Restoring element ${index}:`, element.type, 'Content:', element.content);

                    // Add element back to quizElements
                    quizElements.push(element);

                    // Render element on canvas using the existing renderElement function
                    renderElement(element);
                });

                // Hide placeholder if we have elements
                const placeholder = document.querySelector('.canvas-placeholder');
                if (placeholder && questionPages[currentQuestionIndex].elements.length > 0) {
                    placeholder.style.display = 'none';
                }
            } else {
                console.log('No elements found for page', currentQuestionIndex);
                // Show placeholder if no elements
                const placeholder = document.querySelector('.canvas-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
            }

            updateCurrentPageElements();
            updateQuestionCounter();
            console.log('=== SHOW PAGE COMPLETE ===');
        }

        // Navigate to a specific question page
        function navigateToQuestion(index) {
            if (index < 0 || index >= questionPages.length) return;

            // Save current page
            saveCurrentPageElements();

            currentQuestionIndex = index;
            showCurrentQuestionPage();
            updateNavigationButtons();
        }

        // Render an element on the canvas
        function renderElementOnCanvas(element) {
            // Remove existing element if it exists
            const existingElement = document.getElementById(element.id);
            if (existingElement) {
                existingElement.remove();
            }

            // Create element based on type
            const elementDiv = document.createElement('div');
            elementDiv.id = element.id;
            elementDiv.className = 'quiz-element';
            elementDiv.style.position = 'absolute';
            elementDiv.style.left = element.x + 'px';
            elementDiv.style.top = element.y + 'px';
            elementDiv.style.width = element.width + 'px';
            elementDiv.style.height = element.height + 'px';

            // Add content based on element type
            if (element.type === 'text') {
                elementDiv.innerHTML = `
                    <div class="text-element">
                        <div class="ql-editor" style="min-height: ${element.height}px;">${element.content || 'Enter text here...'}</div>
                    </div>
                `;
            } else if (element.type === 'question') {
                // Use the same rendering as the main renderElement function
                elementDiv.innerHTML = `<div style="padding: 15px; background: #f0f9ff; border-left: 4px solid #0ea5e9;">
                    <strong>Question ${quizElements.filter(e => e.type === 'question').length}:</strong>
                    <div contenteditable="true" style="outline: none; margin-top: 8px;">${element.content || 'Enter your question here...'}</div>
                </div>`;
            } else if (element.type === 'sub-question') {
                // Use the same rendering as the main renderElement function
                elementDiv.innerHTML = `<div style="padding: 12px; background: #fefce8; border-left: 4px solid #eab308; margin-left: 20px;">
                    <strong>Sub-question:</strong>
                    <div contenteditable="true" style="outline: none; margin-top: 8px;">${element.content || 'Enter sub-question here...'}</div>
                </div>`;
            } else if (element.type === 'image') {
                elementDiv.innerHTML = `
                    <div class="image-element">
                        <img src="${element.src || '/placeholder-image.png'}" alt="Quiz Image" style="width: 100%; height: 100%; object-fit: cover;">
                    </div>
                `;
            }

            // Make element draggable and selectable
            makeElementDraggable(elementDiv);
            makeElementSelectable(elementDiv);

            // Add to canvas
            document.getElementById('canvas').appendChild(elementDiv);
        }

        // Update navigation button states
        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prev-question-btn');
            const nextBtn = document.getElementById('next-question-btn');

            if (prevBtn) {
                prevBtn.disabled = currentQuestionIndex <= 0;
            }

            if (nextBtn) {
                // Next button is always enabled (creates new question page if at end)
                nextBtn.disabled = false;

                // Update button text based on whether we're at the last page
                if (currentQuestionIndex === questionPages.length - 1) {
                    nextBtn.innerHTML = '<i class="fas fa-plus"></i>';
                    nextBtn.title = 'Add new question';
                } else {
                    nextBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
                    nextBtn.title = 'Go to next question';
                }
            }
        }

        // Update question counter display
        function updateQuestionCounter() {
            const counter = document.getElementById('question-counter');
            if (counter) {
                counter.textContent = `Q${currentQuestionIndex + 1} of ${questionPages.length}`;
            }
        }

        // Hook into element creation to update navigation
        const originalCreateElement = createElement;
        createElement = function(type, x, y) {
            const result = originalCreateElement.call(this, type, x, y);

            // If a question was created, update navigation
            if (type === 'question' || type === 'sub-question') {
                setTimeout(() => {
                    updateQuestionList();
                    // Navigate to the newly created question
                    const newQuestionIndex = questionElements.length - 1;
                    if (newQuestionIndex >= 0) {
                        navigateToQuestion(newQuestionIndex);
                    }
                }, 100);
            }

            return result;
        };

        // Hook into element deletion to update navigation
        function updateNavigationAfterDelete() {
            updateQuestionList();
            highlightCurrentQuestion();
        }

        // Expose functions globally
        window.nextQuestion = nextQuestion;
        window.previousQuestion = previousQuestion;
        window.initializeQuestionNavigation = initializeQuestionNavigation;
        window.updateNavigationAfterDelete = updateNavigationAfterDelete;

        // Preview quiz
        function previewQuiz() {
            if (quizElements.length === 0) {
                alert('Please add some elements to preview the quiz');
                return;
            }

            // Sync current content from DOM before preview
            syncElementsContent();

            // Create preview window
            const previewWindow = window.open('', '_blank', 'width=800,height=600');
            const previewContent = generatePreviewHTML();

            previewWindow.document.write(previewContent);
            previewWindow.document.close();
        }
        window.previewQuiz = previewQuiz;

        // Generate preview HTML
        function generatePreviewHTML() {
            var elementsHTML = '';

            quizElements.forEach(function(element) {
                var styleString = '';
                for (var key in element.style) {
                    if (element.style.hasOwnProperty(key)) {
                        styleString += key + ': ' + element.style[key] + '; ';
                    }
                }

                // Get the current content from the DOM element (for edited content)
                var currentContent = getCurrentElementContent(element);

                elementsHTML += '<div style="position: absolute; left: ' + element.x + 'px; top: ' + element.y + 'px; width: ' + element.width + 'px; height: ' + element.height + 'px; ' + styleString + '">' +
                    currentContent +
                    '</div>';
            });

            var previewHTML = '<!DOCTYPE html>' +
                '<html>' +
                '<head>' +
                '<title>Quiz Preview - ' + quizSettings.title + '</title>' +
                '<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">' +
                '<style>' +
                'body { font-family: Inter, sans-serif; margin: 20px; background: #f8fafc; }' +
                '.preview-header { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +
                '.preview-canvas { position: relative; background: white; min-height: 800px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +
                '</style>' +
                '</head>' +
                '<body>' +
                '<div class="preview-header">' +
                '<h2>' + quizSettings.title + '</h2>' +
                '<p><strong>Grade:</strong> ' + quizSettings.gradeLevel + ' | <strong>Subject:</strong> ' + quizSettings.subject + '</p>' +
                '<p>' + quizSettings.description + '</p>' +
                '</div>' +
                '<div class="preview-canvas">' +
                elementsHTML +
                '</div>' +
                '</body>' +
                '</html>';

            return previewHTML;
        }

        // Get current content from DOM element (captures edited content)
        function getCurrentElementContent(element) {
            const domElement = document.getElementById(element.id);
            if (!domElement) {
                // Fallback to original content if DOM element not found
                return getElementContent(element);
            }

            switch(element.type) {
                case 'textbox':
                    // Get the current text from contenteditable div
                    const textDiv = domElement.querySelector('[contenteditable="true"]');
                    return textDiv ? '<div>' + textDiv.innerHTML + '</div>' : getElementContent(element);

                case 'table':
                    // Get the current table with all edited cell content
                    const table = domElement.querySelector('table');
                    if (table) {
                        // Clone the table and remove contenteditable and onclick attributes for preview
                        const clonedTable = table.cloneNode(true);
                        const cells = clonedTable.querySelectorAll('td');
                        cells.forEach(cell => {
                            cell.removeAttribute('contenteditable');
                            cell.removeAttribute('onclick');
                            // Clean up the style to remove outline
                            cell.style.outline = 'none';
                        });
                        return clonedTable.outerHTML;
                    }
                    return getElementContent(element);

                case 'question':
                case 'sub-question':
                    // Get current question content
                    const questionDiv = domElement.querySelector('[contenteditable="true"]');
                    if (questionDiv) {
                        const questionType = element.type === 'question' ? 'Question' : 'Sub-question';
                        const bgColor = element.type === 'question' ? '#f0f9ff' : '#fefce8';
                        const borderColor = element.type === 'question' ? '#0ea5e9' : '#eab308';
                        const marginLeft = element.type === 'sub-question' ? 'margin-left: 20px;' : '';

                        return '<div style="padding: 15px; background: ' + bgColor + '; border-left: 4px solid ' + borderColor + '; ' + marginLeft + '">' +
                            '<strong>' + questionType + ':</strong>' +
                            '<div style="margin-top: 8px;">' + questionDiv.innerHTML + '</div>' +
                            '</div>';
                    }
                    return getElementContent(element);

                case 'answer-area':
                    // Get current answer area content
                    const textarea = domElement.querySelector('textarea');
                    if (textarea) {
                        return '<div style="padding: 15px; background: #f0fdf4; border: 2px dashed #22c55e; border-radius: 8px;">' +
                            '<div style="color: #16a34a; font-weight: 600; margin-bottom: 8px;">' +
                            '<i class="fas fa-edit" style="margin-right: 8px;"></i>Answer Area' +
                            '</div>' +
                            '<div style="width: 100%; min-height: 60px; border: 1px solid #e2e8f0; border-radius: 4px; padding: 8px; background: white;">' +
                            (textarea.value || 'Students will write their answer here...') +
                            '</div>' +
                            '</div>';
                    }
                    return getElementContent(element);

                case 'image':
                    // Images should already be properly stored in element.content
                    return getElementContent(element);

                case 'latex':
                    // LaTeX content should be preserved
                    return getElementContent(element);

                default:
                    // For other elements, get the current innerHTML
                    return domElement.innerHTML || getElementContent(element);
            }
        }

        // Sanitize content for safe storage
        function sanitizeContent(content) {
            if (!content) return '';

            // Convert to string
            let sanitized = String(content);

            // Remove excessive whitespace and newlines
            sanitized = sanitized.replace(/\s+/g, ' ').trim();

            // Limit content length
            if (sanitized.length > 5000) {
                sanitized = sanitized.substring(0, 5000) + '...';
            }

            return sanitized;
        }

        // Sync current DOM content back to element data
        function syncElementsContent() {
            quizElements.forEach(function(element) {
                const domElement = document.getElementById(element.id);
                if (!domElement) return;

                try {
                    switch(element.type) {
                        case 'textbox':
                            const textDiv = domElement.querySelector('[contenteditable="true"]');
                            if (textDiv) {
                                element.content = sanitizeContent(textDiv.innerHTML);
                            }
                            break;

                        case 'question':
                        case 'sub-question':
                            const questionDiv = domElement.querySelector('[contenteditable="true"]');
                            if (questionDiv) {
                                element.content = sanitizeContent(questionDiv.innerHTML);
                            }
                            break;

                        case 'answer-area':
                            const textarea = domElement.querySelector('textarea');
                            if (textarea) {
                                element.content = sanitizeContent(textarea.value);
                            }
                            break;

                        case 'table':
                            const table = domElement.querySelector('table');
                            if (table) {
                                // Store the current table HTML (sanitized)
                                element.content = sanitizeContent(table.outerHTML);
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Error syncing content for element:', element.id, error);
                    // Keep existing content if sync fails
                }
            });
        }

        // Save quiz
        function saveQuiz() {
            if (!quizSettings.title) {
                alert('Please set quiz settings first');
                openQuizSettings();
                return;
            }

            if (questionPages.length === 0 || questionPages.every(page => page.elements.length === 0)) {
                alert('Please add some questions to the quiz');
                return;
            }

            // Save current page before saving quiz
            saveCurrentPageElements();

            // Collect all elements from all pages
            const allElements = [];
            questionPages.forEach((page, pageIndex) => {
                page.elements.forEach(element => {
                    // Add page information to element
                    element.pageNumber = pageIndex + 1;
                    element.questionNumber = pageIndex + 1;
                    allElements.push(element);
                });
            });

            // Sync current content from DOM before saving
            syncElementsContent();

            // Clean and optimize elements data
            const cleanElements = allElements.map(element => {
                const cleanElement = {
                    id: element.id || '',
                    type: element.type || '',
                    x: Number(element.x) || 0,
                    y: Number(element.y) || 0,
                    width: Number(element.width) || 200,
                    height: Number(element.height) || 100
                };

                // Only include content if it's not empty and not too large
                if (element.content) {
                    if (element.content.startsWith('data:image/')) {
                        // For images, check size and potentially compress
                        if (element.content.length > 1000000) { // 1MB
                            console.warn('Large image detected, consider compressing');
                        }
                        cleanElement.content = element.content;
                    } else {
                        // For text content, limit size
                        cleanElement.content = element.content.length > 10000
                            ? element.content.substring(0, 10000) + '...'
                            : element.content;
                    }
                }

                // Include shape-specific properties only if they exist
                const shapeProps = ['fillColor', 'strokeColor', 'strokeWidth', 'strokeDasharray',
                                  'shapeLength', 'shapeDiameter', 'shapeSideLength', 'shapeBaseWidth',
                                  'shapeHeight', 'shapeWidth', 'shapeSize', 'shapeDepth',
                                  'objectFit', 'objectPosition'];

                shapeProps.forEach(prop => {
                    if (element[prop] !== undefined && element[prop] !== null) {
                        cleanElement[prop] = element[prop];
                    }
                });

                // Include chart-specific properties only if they exist
                const chartProps = ['chartTitle', 'chartData', 'yAxisLabel', 'xAxisLabel', 'colorTheme'];
                chartProps.forEach(prop => {
                    if (element[prop] !== undefined && element[prop] !== null) {
                        cleanElement[prop] = element[prop];
                    }
                });

                // Only include style if it has properties
                if (element.style && Object.keys(element.style).length > 0) {
                    cleanElement.style = element.style;
                }

                return cleanElement;
            });

            const quizData = {
                ...quizSettings,
                elements: cleanElements,
                isComplexQuiz: true
            };

            // Calculate approximate payload size
            const payloadSize = JSON.stringify(quizData).length;
            const payloadSizeMB = (payloadSize / (1024 * 1024)).toFixed(2);

            console.log('Sending quiz data:', {
                title: quizSettings.title,
                elementsCount: cleanElements.length,
                payloadSizeMB: payloadSizeMB + ' MB'
            });

            // Warn if payload is very large
            if (payloadSize > 40 * 1024 * 1024) { // 40MB
                if (!confirm(`Warning: This quiz contains a lot of data (${payloadSizeMB} MB). This may take longer to save. Continue?`)) {
                    return;
                }
            }

            // Send to server
            fetch('/create-complex-quiz', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(quizData)
            })
            .then(response => {
                console.log('Server response status:', response.status);
                if (!response.ok) {
                    if (response.status === 413) {
                        throw new Error('Quiz data is too large. Please reduce the number of elements or compress images.');
                    }
                    throw new Error('Server responded with status: ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                console.log('Server response data:', data);
                if (data.success) {
                    // Show success message with preview option
                    const userChoice = confirm(
                        'Quiz saved successfully!\n\n' +
                        'Would you like to preview the quiz now?\n\n' +
                        'Click "OK" to preview or "Cancel" to return to dashboard.'
                    );

                    if (userChoice && data.quizId) {
                        // Open preview in new tab
                        window.open(`/view-quiz/${data.quizId}`, '_blank');
                        // Also redirect to dashboard
                        setTimeout(() => {
                            window.location.href = '/teacher/dashboard';
                        }, 1000);
                    } else {
                        window.location.href = '/teacher/dashboard';
                    }
                } else {
                    console.error('Save failed:', data);
                    alert('Error saving quiz: ' + data.message + (data.details ? '\nDetails: ' + data.details.join(', ') : ''));
                }
            })
            .catch(error => {
                console.error('Error saving quiz:', error);

                let errorMessage = 'Error saving quiz: ' + error.message;

                // Provide specific guidance for common errors
                if (error.message.includes('too large')) {
                    errorMessage += '\n\nTips to reduce quiz size:\n' +
                                  ' Remove or compress large images\n' +
                                  ' Reduce the number of elements\n' +
                                  ' Simplify complex content';
                } else if (error.message.includes('413') || error.message.includes('entity too large')) {
                    errorMessage = 'Quiz data is too large for the server to process.\n\n' +
                                  'Please try:\n' +
                                  ' Removing some elements\n' +
                                  ' Compressing or removing large images\n' +
                                  ' Simplifying chart data';
                }

                alert(errorMessage);
            });
        }
        window.saveQuiz = saveQuiz;

        // Clear canvas of all elements
        function clearCanvas() {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                // Remove all canvas elements
                const elements = canvas.querySelectorAll('.canvas-element');
                elements.forEach(element => element.remove());

                // Clear quizElements array
                quizElements.length = 0;

                // Show placeholder if no elements
                const placeholder = document.querySelector('.canvas-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
            }
        }

        // Export quiz to PDF
        async function exportToPDF() {
            try {
                // Save current page elements before export
                saveCurrentPageElements();

                // Check if there are any elements to export
                if (questionPages.length === 0 || questionPages.every(page => page.elements.length === 0)) {
                    alert('Please add some elements to the quiz before exporting to PDF');
                    return;
                }

                // Show loading indicator
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'pdf-loading';
                loadingDiv.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    color: white;
                    font-size: 18px;
                `;
                loadingDiv.innerHTML = `
                    <div style="text-align: center;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px;"></i><br>
                        Generating PDF...
                    </div>
                `;
                document.body.appendChild(loadingDiv);

                // Ensure MathJax is fully loaded before proceeding
                if (window.MathJax) {
                    try {
                        loadingDiv.innerHTML = `
                            <div style="text-align: center;">
                                <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px;"></i><br>
                                Preparing equations...
                            </div>
                        `;
                        await window.MathJax.startup.promise;

                        // Temporarily disable auto-processing to prevent double rendering
                        const originalProcessReset = window.MathJax.startup.document.state;

                        console.log('MathJax is ready for PDF export');
                    } catch (mathError) {
                        console.warn('MathJax loading error:', mathError);
                    }
                }

                // Initialize jsPDF
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');

                // PDF dimensions
                const pageWidth = 210; // A4 width in mm
                const pageHeight = 297; // A4 height in mm
                const margin = 20;
                const contentWidth = pageWidth - (margin * 2);
                const contentHeight = pageHeight - (margin * 2);

                // Add title page
                pdf.setFontSize(24);
                pdf.setFont(undefined, 'bold');
                const title = quizSettings.title || 'Complex Quiz';
                pdf.text(title, pageWidth / 2, 40, { align: 'center' });

                pdf.setFontSize(14);
                pdf.setFont(undefined, 'normal');
                if (quizSettings.description) {
                    const splitDescription = pdf.splitTextToSize(quizSettings.description, contentWidth);
                    pdf.text(splitDescription, margin, 60);
                }

                // Add quiz metadata
                let yPos = 100;
                if (quizSettings.gradeLevel) {
                    pdf.text(`Grade Level: ${quizSettings.gradeLevel}`, margin, yPos);
                    yPos += 10;
                }
                if (quizSettings.subjects && quizSettings.subjects.length > 0) {
                    pdf.text(`Subjects: ${quizSettings.subjects.join(', ')}`, margin, yPos);
                    yPos += 10;
                }
                if (quizSettings.language) {
                    pdf.text(`Language: ${quizSettings.language}`, margin, yPos);
                    yPos += 10;
                }

                pdf.text(`Total Questions: ${questionPages.length}`, margin, yPos);
                yPos += 10;
                pdf.text(`Created: ${new Date().toLocaleDateString()}`, margin, yPos);

                // Process each question page
                for (let pageIndex = 0; pageIndex < questionPages.length; pageIndex++) {
                    const page = questionPages[pageIndex];

                    if (page.elements.length === 0) continue;

                    // Add new page for each question
                    pdf.addPage();

                    // Add page header
                    pdf.setFontSize(16);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(`Question ${pageIndex + 1}`, margin, 25);

                    // Create a temporary canvas for this page
                    const tempCanvas = document.createElement('div');
                    tempCanvas.style.cssText = `
                        position: absolute;
                        top: -10000px;
                        left: -10000px;
                        width: 800px;
                        height: 600px;
                        background: white;
                        border: 1px solid #e2e8f0;
                        font-family: Inter, sans-serif;
                        overflow: visible;
                        z-index: -1000;
                    `;
                    tempCanvas.className = 'pdf-equation-container';
                    document.body.appendChild(tempCanvas);

                    // Render elements on temporary canvas
                    page.elements.forEach(element => {
                        const elementDiv = document.createElement('div');
                        elementDiv.style.cssText = `
                            position: absolute;
                            left: ${element.x}px;
                            top: ${element.y}px;
                            width: ${element.width}px;
                            height: ${element.height}px;
                            font-family: Inter, sans-serif;
                        `;

                        // Apply element styles
                        if (element.style) {
                            Object.assign(elementDiv.style, element.style);
                        }

                        // Add content based on element type
                        elementDiv.innerHTML = getElementContentForPDF(element);
                        tempCanvas.appendChild(elementDiv);
                    });

                    // Wait for DOM to be ready before MathJax processing
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Process MathJax equations only once with controlled rendering
                    if (window.MathJax) {
                        try {
                            // Clear any existing MathJax processing in the temp canvas
                            const existingMath = tempCanvas.querySelectorAll('.MathJax, mjx-container, mjx-assistive-mml');
                            existingMath.forEach(el => el.remove());

                            // Find all math content elements
                            const mathElements = tempCanvas.querySelectorAll('.pdf-math-content');

                            // Process each math element individually to prevent duplication
                            for (const mathEl of mathElements) {
                                const latex = mathEl.getAttribute('data-latex');
                                if (latex) {
                                    // Clear existing content and set fresh LaTeX
                                    mathEl.innerHTML = `\\[${latex}\\]`;
                                }
                            }

                            // Process equations fresh
                            await MathJax.typesetPromise([tempCanvas]);
                            console.log('MathJax rendered for PDF page', pageIndex + 1);

                            // Wait for rendering to complete
                            await new Promise(resolve => setTimeout(resolve, 800));
                        } catch (mathError) {
                            console.warn('MathJax rendering error:', mathError);
                        }
                    }

                    // Final delay to ensure all rendering is complete
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Convert canvas to image using html2canvas with optimized settings for equations
                    try {
                        const canvas = await html2canvas(tempCanvas, {
                            backgroundColor: '#ffffff',
                            scale: 3, // Higher scale for better equation quality
                            useCORS: true,
                            allowTaint: true,
                            logging: false,
                            width: tempCanvas.offsetWidth,
                            height: tempCanvas.offsetHeight,
                            scrollX: 0,
                            scrollY: 0,
                            windowWidth: tempCanvas.offsetWidth,
                            windowHeight: tempCanvas.offsetHeight
                        });

                        const imgData = canvas.toDataURL('image/png');

                        // Calculate dimensions to fit in PDF
                        const imgWidth = contentWidth;
                        const imgHeight = (canvas.height * imgWidth) / canvas.width;

                        // Add image to PDF
                        if (imgHeight <= contentHeight - 20) {
                            pdf.addImage(imgData, 'PNG', margin, 35, imgWidth, imgHeight);
                        } else {
                            // Scale down if too large
                            const scaledHeight = contentHeight - 20;
                            const scaledWidth = (canvas.width * scaledHeight) / canvas.height;
                            pdf.addImage(imgData, 'PNG', margin, 35, scaledWidth, scaledHeight);
                        }
                    } catch (error) {
                        console.error('Error capturing page:', error);
                        // Add error message to PDF
                        pdf.setFontSize(12);
                        pdf.setTextColor(255, 0, 0);
                        pdf.text('Error rendering this question page', margin, 50);
                        pdf.setTextColor(0, 0, 0);
                    }

                    // Clean up temporary canvas
                    document.body.removeChild(tempCanvas);
                }

                // Save the PDF
                const fileName = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_quiz.pdf`;
                pdf.save(fileName);

                // Remove loading indicator
                document.body.removeChild(loadingDiv);

                // Show success message
                alert(`PDF exported successfully as "${fileName}"`);

            } catch (error) {
                console.error('Error exporting PDF:', error);

                // Remove loading indicator if it exists
                const loadingDiv = document.getElementById('pdf-loading');
                if (loadingDiv) {
                    document.body.removeChild(loadingDiv);
                }

                alert('Error exporting PDF: ' + error.message);
            }
        }

        // Get element content formatted for PDF export
        function getElementContentForPDF(element) {
            switch (element.type) {
                case 'textbox':
                case 'text':
                    return `<div style="padding: 10px; word-wrap: break-word; overflow-wrap: break-word;">${element.content || 'Text content'}</div>`;
                case 'question':
                    return `<div style="padding: 15px; background: #f0f9ff; border-left: 4px solid #0ea5e9; word-wrap: break-word;">
                        <strong>Question:</strong><br>
                        <div style="margin-top: 8px;">${element.content || 'Question content'}</div>
                    </div>`;
                case 'sub-question':
                    return `<div style="padding: 12px; background: #f0fdf4; border-left: 3px solid #22c55e; word-wrap: break-word;">
                        <strong>Sub-question:</strong><br>
                        <div style="margin-top: 6px;">${element.content || 'Sub-question content'}</div>
                    </div>`;
                case 'answer-area':
                    return `<div style="padding: 15px; background: #f0fdf4; border: 2px dashed #22c55e; border-radius: 8px;">
                        <strong>Answer Area</strong><br>
                        <div style="margin-top: 10px; min-height: 40px; background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 8px;">
                            ${element.content || 'Student answer area'}
                        </div>
                    </div>`;
                case 'image':
                    if (element.src) {
                        return `<img src="${element.src}" style="max-width: 100%; max-height: 100%; object-fit: contain;" alt="Quiz image">`;
                    }
                    return `<div style="padding: 20px; background: #f3f4f6; border: 2px dashed #9ca3af; text-align: center; color: #6b7280;">
                        <i class="fas fa-image" style="font-size: 24px; margin-bottom: 8px;"></i><br>
                        Image placeholder
                    </div>`;
                case 'table':
                    return `<div style="padding: 10px; border: 1px solid #e5e7eb;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <tr><td style="border: 1px solid #d1d5db; padding: 8px;">Table</td><td style="border: 1px solid #d1d5db; padding: 8px;">Content</td></tr>
                            <tr><td style="border: 1px solid #d1d5db; padding: 8px;">Row 1</td><td style="border: 1px solid #d1d5db; padding: 8px;">Data</td></tr>
                        </table>
                    </div>`;
                case 'latex':
                case 'equation':
                    // Render LaTeX as actual math equation for PDF with proper spacing
                    const latexContent = element.content || '\\sum_{i=1}^{n} x_i';
                    return `<div style="padding: 20px; text-align: center; font-size: 18px; line-height: 2.5; min-height: 80px; display: flex; align-items: center; justify-content: center; background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; margin: 10px 0;">
                        <div class="pdf-math-content" style="padding: 15px;" data-latex="${latexContent.replace(/"/g, '&quot;')}">\\[${latexContent}\\]</div>
                    </div>`;
                case 'math-equation':
                    const equationType = element.equationType || 'simple';
                    let equationContent = element.content || 'x + 5 = 12';

                    if (equationType === 'complex') {
                        // Complex equations use LaTeX syntax with improved spacing
                        equationContent = element.content || '\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}';
                        return `<div style="padding: 25px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center; margin: 15px 0;">
                            <div style="font-size: 20px; color: #1e40af; min-height: 80px; line-height: 3; display: flex; align-items: center; justify-content: center; padding: 20px;">
                                <div class="pdf-math-content" style="padding: 10px;" data-latex="${equationContent.replace(/"/g, '&quot;')}">\\[${equationContent}\\]</div>
                            </div>
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #93c5fd;">
                                <small style="color: #64748b; font-weight: 600;">Complex Equation</small>
                            </div>
                        </div>`;
                    } else {
                        // Simple equations as plain text
                        return `<div style="padding: 20px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center; margin: 10px 0;">
                            <div style="font-size: 18px; font-weight: bold; color: #1e40af; padding: 10px;">${equationContent}</div>
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #93c5fd;">
                                <small style="color: #64748b; font-weight: 600;">Simple Equation</small>
                            </div>
                        </div>`;
                    }
                case 'math-expression':
                    return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                        <div style="font-size: 18px; font-weight: bold; color: #1e40af;">${element.content || '2x + 3y'}</div>
                        <small style="color: #64748b;">Expression</small>
                    </div>`;
                case 'math-formula':
                    return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                        <div style="font-size: 16px; font-weight: bold; color: #1e40af;">${element.content || 'A = r'}</div>
                        <small style="color: #64748b;">Formula</small>
                    </div>`;
                case 'math-fraction':
                    return `<div style="padding: 15px; background: #f0f9ff; border: 2px solid #3b82f6; border-radius: 8px; text-align: center;">
                        <div style="font-size: 18px; color: #1e40af; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 60px;">
                            <div style="border-bottom: 2px solid #1e40af; padding: 5px; font-size: 18px; font-weight: bold;">${element.numerator || '3'}</div>
                            <div style="padding: 5px; font-size: 18px; font-weight: bold;">${element.denominator || '4'}</div>
                        </div>
                        <small style="color: #64748b;">Fraction</small>
                    </div>`;
                case 'circle':
                    return `<div style="width: 100%; height: 100%; border-radius: 50%; background: ${element.style?.backgroundColor || '#e5e7eb'}; border: 2px solid ${element.style?.borderColor || '#9ca3af'};"></div>`;
                case 'square':
                case 'rectangle':
                    return `<div style="width: 100%; height: 100%; background: ${element.style?.backgroundColor || '#e5e7eb'}; border: 2px solid ${element.style?.borderColor || '#9ca3af'};"></div>`;
                case 'triangle':
                    return `<div style="width: 0; height: 0; border-left: ${element.width/2}px solid transparent; border-right: ${element.width/2}px solid transparent; border-bottom: ${element.height}px solid ${element.style?.backgroundColor || '#e5e7eb'};"></div>`;
                case 'line':
                    return `<div style="width: 100%; height: 2px; background: ${element.style?.backgroundColor || '#9ca3af'}; margin-top: ${element.height/2}px;"></div>`;
                default:
                    return `<div style="padding: 10px; background: #f3f4f6; border: 1px solid #d1d5db; word-wrap: break-word;">
                        ${element.content || element.type}
                    </div>`;
            }
        }

        // Toggle Math category dropdown
        function toggleMathCategory() {
            const mathElements = document.getElementById('math-elements');
            const chevron = document.getElementById('math-chevron');

            if (mathElements.style.display === 'none' || mathElements.style.display === '') {
                mathElements.style.display = 'block';
                chevron.classList.add('rotated');
            } else {
                mathElements.style.display = 'none';
                chevron.classList.remove('rotated');
            }
        }

        // Make functions globally available for onclick handlers
        window.addElementToCanvas = addElementToCanvas;
        window.toggleMathCategory = toggleMathCategory;
        window.testDragDrop = testDragDrop;
        window.clearCanvas = clearCanvas;
        window.previewQuiz = previewQuiz;
        window.saveQuiz = saveQuiz;
        window.exportToPDF = exportToPDF;
        window.saveQuizSettings = saveQuizSettings;
        window.openQuizSettings = openQuizSettings;
        window.nextQuestion = nextQuestion;
        window.previousQuestion = previousQuestion;
        window.navigateToQuestion = navigateToQuestion;
        window.saveCurrentPageElements = saveCurrentPageElements;
        window.showCurrentQuestionPage = showCurrentQuestionPage;
        window.deleteElement = deleteElement;
        window.duplicateElement = duplicateElement;
        window.updateElementProperty = updateElementProperty;
        window.updateElementStyle = updateElementStyle;
        window.updateLatexContent = updateLatexContent;
        window.handleImageUpload = handleImageUpload;
        window.showCanvasInstructions = showCanvasInstructions;
    </script>
</body>
</html>
