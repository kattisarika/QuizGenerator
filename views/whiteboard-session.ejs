<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= session.title %> - Whiteboard Session - SkillOns</title>
    <link rel="stylesheet" href="/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Fallback Socket.IO client if server version fails
        if (typeof io === 'undefined') {
            console.log('üîµ Loading fallback Socket.IO client from CDN');
            const script = document.createElement('script');
            script.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js';
            script.onload = function() {
                console.log('üîµ Fallback Socket.IO client loaded successfully');
                // Reinitialize if already tried
                if (typeof initializeSocketIO === 'function') {
                    initializeSocketIO();
                }
            };
            script.onerror = function() {
                console.error('üî¥ Failed to load fallback Socket.IO client');
            };
            document.head.appendChild(script);
        }
    </script>
    <style>
        :root {
            --primary-color: #4F46E5;
            --primary-dark: #4338CA;
            --secondary-color: #7C3AED;
            --success-color: #10B981;
            --warning-color: #F59E0B;
            --danger-color: #EF4444;
            --info-color: #3B82F6;
            --dark-color: #1F2937;
            --light-color: #F9FAFB;
            --border-radius: 8px;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            color: var(--dark-color);
            overflow: hidden;
        }

        /* Enhanced Navbar */
        .navbar {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-md);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 70px;
        }

        .nav-logo a {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary-color);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-logo a::before {
            content: "üë®‚Äçüè´";
            font-size: 28px;
        }

        .nav-menu {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .nav-link {
            padding: 10px 16px;
            color: #333;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-weight: 500;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: #f9fafb;
            color: var(--primary-color);
            transform: translateY(-2px);
        }

        .nav-link.logout-btn {
            background: #dc3545;
            color: white;
        }

        .nav-link.logout-btn:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        /* Session Header */
        .session-header {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 70px;
        }

        .session-info h1 {
            font-size: 20px;
            color: var(--dark-color);
            margin-bottom: 5px;
        }

        .session-meta {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #6b7280;
        }

        .session-controls {
            display: flex;
            gap: 10px;
        }

        /* Toolbar */
        .toolbar {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 5px 10px;
            border-radius: 6px;
            background: #f9fafb;
        }

        .tool-group label {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            margin-right: 5px;
        }

        .tool-btn {
            padding: 8px 12px;
            border: 2px solid transparent;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        .tool-btn:hover {
            border-color: var(--primary-color);
            background: #f0f9ff;
        }

        .tool-btn.active {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
        }

        .tool-btn i {
            font-size: 16px;
        }

        .color-picker {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background: #000;
        }

        .size-slider {
            width: 80px;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            background: #fafafa;
            overflow: hidden;
        }

        #whiteboard-canvas {
            border: 1px solid #e5e7eb;
            cursor: crosshair;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: white;
            border-left: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #f3f4f6;
        }

        .sidebar-section h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--dark-color);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .participants-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .participant-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 5px;
            background: #f9fafb;
        }

        .participant-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
        }

        .participant-info {
            flex: 1;
        }

        .participant-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--dark-color);
        }

        .participant-role {
            font-size: 12px;
            color: #6b7280;
        }

        .participant-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success-color);
        }

        .participant-status.offline {
            background: #9ca3af;
        }

        /* File Upload */
        .file-upload {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .file-upload:hover {
            border-color: var(--primary-color);
            background: #f0f9ff;
        }

        .file-upload i {
            font-size: 24px;
            color: #9ca3af;
            margin-bottom: 10px;
        }

        .file-upload p {
            color: #6b7280;
            font-size: 14px;
        }

        /* Math Input */
        .math-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .math-input input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }

        .math-input button {
            padding: 8px 16px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        /* Main Layout */
        .whiteboard-layout {
            display: flex;
            height: calc(100vh - 140px);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-warning {
            background: var(--warning-color);
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .sidebar {
                width: 250px;
            }
        }

        @media (max-width: 768px) {
            .whiteboard-layout {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: 200px;
            }

            .toolbar {
                flex-wrap: wrap;
                gap: 10px;
            }

            .tool-group {
                flex: 1;
                min-width: 120px;
            }

            .session-header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .session-controls {
                width: 100%;
                justify-content: space-between;
            }
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #6b7280;
        }

        .loading i {
            font-size: 24px;
            margin-right: 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Error States */
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
        }

        /* Success States */
        .success-message {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: #16a34a;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
        }

        /* Student-specific styles */
        .student-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .session-status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
        }

        .status-live {
            color: var(--success-color);
        }

        .status-paused {
            color: var(--warning-color);
        }

        .status-recorded {
            color: var(--info-color);
        }

        .collaboration-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            padding: 8px 12px;
            background: #f0f9ff;
            border-radius: 6px;
            color: var(--info-color);
        }

        .session-info-card {
            background: #f9fafb;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .session-info-card p {
            margin-bottom: 10px;
            font-size: 14px;
        }

        .session-info-card p:last-child {
            margin-bottom: 0;
        }

        .badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-success {
            background: #d1fae5;
            color: #065f46;
        }

        .badge-info {
            background: #dbeafe;
            color: #1e40af;
        }

        .badge-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .text-success {
            color: var(--success-color);
        }

        .text-info {
            color: var(--info-color);
        }

        .empty-state {
            text-align: center;
            padding: 20px;
            color: #6b7280;
        }

        .empty-state p {
            margin: 0;
            font-style: italic;
        }

        .connection-status {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .connection-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            padding: 6px 12px;
            border-radius: 20px;
            background: #f3f4f6;
            color: #6b7280;
        }

        .connection-indicator.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .connection-indicator.disconnected {
            background: #fef2f2;
            color: #dc2626;
        }

        .connection-indicator i {
            font-size: 8px;
        }

        /* Debug Panel Styles */
        .debug-panel {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 350px;
            max-height: 500px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            overflow: hidden;
        }

        .debug-header {
            background: #f3f4f6;
            padding: 15px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-header h4 {
            margin: 0;
            font-size: 16px;
            color: var(--dark-color);
        }

        .debug-content {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .debug-section {
            margin-bottom: 20px;
        }

        .debug-section h5 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: var(--primary-color);
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 5px;
        }

        .debug-section p {
            margin: 5px 0;
            font-size: 12px;
            color: #6b7280;
        }

        .debug-events {
            max-height: 150px;
            overflow-y: auto;
            background: #f9fafb;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }

        .debug-events p {
            margin: 2px 0;
            font-size: 11px;
            font-family: monospace;
        }

        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="/">SkillOns</a>
            </div>
            <div class="nav-menu">
                <a href="/whiteboard" class="nav-link">
                    <i class="fas fa-arrow-left"></i> Back to Whiteboard
                </a>
                <a href="/teacher/dashboard" class="nav-link">
                    <i class="fas fa-home"></i> Dashboard
                </a>
                <a href="/logout" class="nav-link logout-btn">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </a>
            </div>
        </div>
    </nav>

    <!-- Session Header -->
    <div class="session-header">
        <div class="session-info">
            <h1><%= session.title %></h1>
                                <div class="session-meta">
                        <span><i class="fas fa-graduation-cap"></i> <%= session.gradeLevel || 'Not specified' %></span>
                        <span><i class="fas fa-book"></i> <%= session.subject || 'Not specified' %></span>
                        <span><i class="fas fa-users"></i> <%= session.participants ? session.participants.length : 0 %> participants</span>
                        <span><i class="fas fa-clock"></i> <%= session.sessionMode || 'live' %></span>
                    </div>
        </div>
        <div class="session-controls">
                    <div class="connection-status">
            <span id="connectionIndicator" class="connection-indicator">
                <i class="fas fa-circle"></i> Connecting...
            </span>
            <button class="btn btn-sm btn-info" onclick="toggleDebugPanel()" style="margin-left: 10px;">
                <i class="fas fa-bug"></i> Debug
            </button>
            <button class="btn btn-sm btn-success" onclick="testRealTimeSync()" style="margin-left: 10px;">
                <i class="fas fa-broadcast-tower"></i> Test Sync
            </button>
            <button class="btn btn-sm btn-warning" onclick="testDrawing()" style="margin-left: 10px;">
                <i class="fas fa-pen"></i> Test Drawing
            </button>
            <button class="btn btn-sm btn-primary" onclick="forceDrawingMode()" style="margin-left: 10px;">
                <i class="fas fa-magic"></i> Force Draw Mode
            </button>
            <button class="btn btn-sm btn-danger" onclick="testCompleteFlow()" style="margin-left: 10px;">
                <i class="fas fa-play"></i> Test Flow
            </button>
            <button class="btn btn-sm btn-info" onclick="testSocketConnection()" style="margin-left: 10px;">
                <i class="fas fa-wifi"></i> Test Socket
            </button>
            <button class="btn btn-sm btn-warning" onclick="verifySessionRoom()" style="margin-left: 10px;">
                <i class="fas fa-check-circle"></i> Verify Room
            </button>
            <button class="btn btn-sm btn-success" onclick="toggleNetworkMonitoring()" style="margin-left: 10px;">
                <i class="fas fa-network-wired"></i> Network
            </button>
            <button class="btn btn-sm btn-danger" onclick="retrySocketIO()" style="margin-left: 10px;">
                <i class="fas fa-redo"></i> Retry Socket
            </button>
            <button class="btn btn-sm btn-info" onclick="checkServerStatus()" style="margin-left: 10px;">
                <i class="fas fa-server"></i> Server Status
            </button>
        </div>
            
            <% if (isTeacher) { %>
                <button class="btn btn-warning" onclick="pauseSession()" id="pauseBtn">
                    <i class="fas fa-pause"></i> Pause
                </button>
                <button class="btn btn-success" onclick="resumeSession()" id="resumeBtn" style="display: none;">
                    <i class="fas fa-play"></i> Resume
                </button>
                <button class="btn btn-danger" onclick="endSession()">
                    <i class="fas fa-stop"></i> End Session
                </button>
                <button class="btn btn-secondary" onclick="takeSnapshot()">
                    <i class="fas fa-camera"></i> Snapshot
                </button>
                <button class="btn btn-primary" onclick="exportSession()">
                    <i class="fas fa-download"></i> Export
                </button>
            <% } else { %>
                <div class="student-controls">
                    <span class="session-status-badge">
                        <i class="fas fa-circle"></i> 
                        <% if (session.status === 'active') { %>
                            <span class="status-live">Live</span>
                        <% } else if (session.status === 'paused') { %>
                            <span class="status-paused">Paused</span>
                        <% } else { %>
                            <span class="status-recorded">Recorded</span>
                        <% } %>
                    </span>
                </div>
            <% } %>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <div class="tool-group">
            <label>Tools:</label>
            <button class="tool-btn active" onclick="setTool('select')" data-tool="select">
                <i class="fas fa-mouse-pointer"></i> Select
            </button>
            <% if (isTeacher || (session.collaborationSettings && session.collaborationSettings.studentDrawingEnabled === true)) { %>
                <button class="tool-btn" onclick="setTool('pen')" data-tool="pen">
                    <i class="fas fa-pen"></i> Pen
                </button>
                <button class="tool-btn" onclick="setTool('eraser')" data-tool="eraser">
                    <i class="fas fa-eraser"></i> Eraser
                </button>
                <button class="tool-btn" onclick="setTool('text')" data-tool="text">
                    <i class="fas fa-font"></i> Text
                </button>
                <button class="tool-btn" onclick="setTool('shape')" data-tool="shape">
                    <i class="fas fa-shapes"></i> Shapes
                </button>
            <% } %>
        </div>

        <% if (isTeacher || (session.collaborationSettings && session.collaborationSettings.studentDrawingEnabled === true)) { %>
            <div class="tool-group">
                <label>Color:</label>
                <input type="color" class="color-picker" id="colorPicker" value="#000000">
            </div>

            <div class="tool-group">
                <label>Size:</label>
                <input type="range" class="size-slider" id="sizeSlider" min="1" max="20" value="3">
                <span id="sizeValue">3</span>
            </div>

            <div class="tool-group">
                <button class="btn btn-secondary" onclick="clearCanvas()">
                    <i class="fas fa-trash"></i> Clear
                </button>
                <button class="btn btn-secondary" onclick="undo()">
                    <i class="fas fa-undo"></i> Undo
                </button>
                <button class="btn btn-secondary" onclick="redo()">
                    <i class="fas fa-redo"></i> Redo
                </button>
                <button class="btn btn-primary" onclick="testCanvas()">
                    <i class="fas fa-vial"></i> Test Canvas
                </button>
            </div>
        <% } %>
        
        <% if (!isTeacher) { %>
            <div class="tool-group">
                <span class="collaboration-status">
                    <% if (session.collaborationSettings && session.collaborationSettings.studentDrawingEnabled === true) { %>
                        <i class="fas fa-check-circle text-success"></i> Drawing Enabled
                    <% } else { %>
                        <i class="fas fa-eye text-info"></i> View Only Mode
                    <% } %>
                </span>
            </div>
        <% } %>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" class="debug-panel" style="display: none;">
        <div class="debug-header">
            <h4><i class="fas fa-bug"></i> Debug Panel</h4>
            <button onclick="toggleDebugPanel()" class="btn btn-sm btn-secondary">√ó</button>
        </div>
        <div class="debug-content">
            <div class="debug-section">
                <h5>Connection Status</h5>
                <p>Socket Connected: <span id="debugSocketStatus">Checking...</span></p>
                <p>Session ID: <span id="debugSessionId"><%= session._id %></span></p>
                <p>User Role: <span id="debugUserRole"><%= user.role %></span></p>
            </div>
            <div class="debug-section">
                <h5>Canvas Info</h5>
                <p>Objects Count: <span id="debugObjectCount">0</span></p>
                <p>Drawing Mode: <span id="debugDrawingMode">false</span></p>
                <p>Current Tool: <span id="debugCurrentTool">select</span></p>
                <p>Drawing Brush: <span id="debugDrawingBrush">Not set</span></p>
                <p>Canvas Size: <span id="debugCanvasSize">0x0</span></p>
            </div>
            <div class="debug-section">
                <h5>Real-Time Events</h5>
                <div id="debugEvents" class="debug-events">
                    <p>No events yet</p>
                </div>
            </div>
            <div class="debug-section">
                <h5>Socket.IO Status</h5>
                <p>Connection ID: <span id="debugSocketId">Unknown</span></p>
                <p>Session Room: <span id="debugSessionRoom">Unknown</span></p>
                <p>Last Event: <span id="debugLastEvent">None</span></p>
                <p>Events Sent: <span id="debugEventsSent">0</span></p>
                <p>Events Received: <span id="debugEventsReceived">0</span></p>
            </div>
            <div class="debug-section">
                <h5>Network Status</h5>
                <p>Latency: <span id="debugLatency">Unknown</span></p>
                <p>Quality: <span id="debugQuality">Unknown</span></p>
                <p>Monitoring: <span id="debugMonitoring">Stopped</span></p>
                <p>Last Ping: <span id="debugLastPing">Never</span></p>
            </div>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="whiteboard-layout">
        <!-- Main Content -->
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="whiteboard-canvas" width="1200" height="800"></canvas>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Participants -->
            <div class="sidebar-section">
                <h3><i class="fas fa-users"></i> Participants</h3>
                <div class="participants-list" id="participantsList">
                    <% if (session.participants && session.participants.length > 0) { %>
                        <% session.participants.forEach(participant => { %>
                            <% if (participant.user && participant.user.displayName) { %>
                                <div class="participant-item">
                                    <div class="participant-avatar">
                                        <%= participant.user.displayName.charAt(0).toUpperCase() %>
                                    </div>
                                    <div class="participant-info">
                                        <div class="participant-name"><%= participant.user.displayName %></div>
                                        <div class="participant-role"><%= participant.role || 'Student' %></div>
                                    </div>
                                    <div class="participant-status"></div>
                                </div>
                            <% } %>
                        <% }); %>
                    <% } else { %>
                        <div class="empty-state">
                            <p>No participants yet</p>
                        </div>
                    <% } %>
                </div>
            </div>

            <!-- File Upload -->
            <% if (isTeacher) { %>
                <div class="sidebar-section">
                    <h3><i class="fas fa-upload"></i> Upload Files</h3>
                    <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <p>Click to upload PDF, images, or PowerPoint</p>
                    </div>
                    <input type="file" id="fileInput" style="display: none" accept=".pdf,.jpg,.jpeg,.png,.gif,.ppt,.pptx" onchange="handleFileUpload(event)">
                </div>
            <% } else { %>
                <!-- Student View -->
                <div class="sidebar-section">
                    <h3><i class="fas fa-info-circle"></i> Session Information</h3>
                    <div class="session-info-card">
                        <p><strong>Mode:</strong> 
                                                    <% if (session.collaborationSettings && session.collaborationSettings.studentDrawingEnabled === true) { %>
                            <span class="badge badge-success">Interactive</span>
                        <% } else { %>
                            <span class="badge badge-info">View Only</span>
                        <% } %>
                        </p>
                        <p><strong>Drawing:</strong> 
                            <% if (session.collaborationSettings && session.collaborationSettings.studentDrawingEnabled === true) { %>
                                <span class="badge badge-success">Enabled</span>
                            <% } else { %>
                                <span class="badge badge-secondary">Disabled</span>
                            <% } %>
                        </p>
                        <p><strong>Writing:</strong> 
                            <% if (session.collaborationSettings && session.collaborationSettings.studentWritingEnabled === true) { %>
                                <span class="badge badge-success">Enabled</span>
                            <% } else { %>
                                <span class="badge badge-secondary">Disabled</span>
                            <% } %>
                        </p>
                    </div>
                </div>
            <% } %>

            <!-- Math Equations -->
            <div class="sidebar-section">
                <h3><i class="fas fa-square-root-alt"></i> Math Equations</h3>
                <div class="math-input">
                    <input type="text" id="mathInput" placeholder="Enter LaTeX equation...">
                    <button onclick="addMathEquation()">Add</button>
                </div>
                <div class="help-text">
                    <small>Use LaTeX syntax: \frac{a}{b}, \sqrt{x}, \int_0^1 dx</small>
                </div>
            </div>

            <!-- Session Info -->
            <div class="sidebar-section">
                <h3><i class="fas fa-info-circle"></i> Session Info</h3>
                <p><strong>Created:</strong> <%= session.createdAt ? new Date(session.createdAt).toLocaleDateString() : 'Not specified' %></p>
                <p><strong>Status:</strong> <span class="badge badge-<%= session.status || 'active' %>"><%= session.status || 'active' %></span></p>
                <p><strong>Mode:</strong> <%= session.sessionMode || 'live' %></p>
                <% if (session.description) { %>
                    <p><strong>Description:</strong> <%= session.description %></p>
                <% } %>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas;
        let currentTool = 'select';
        let currentColor = '#000000';
        let currentSize = 3;
        let isDrawing = false;
        let undoStack = [];
        let redoStack = [];
        let lastSaveTime = Date.now();
        let socket;
        let isConnected = false;
        
        // Socket.IO event tracking
        let lastSocketEvent = 'None';
        let socketEventsSent = 0;
        let socketEventsReceived = 0;
        
        // Network monitoring
        let networkLatency = 0;
        let connectionQuality = 'Unknown';
        let lastPingTime = 0;
        let pingInterval;

        // Initialize whiteboard
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîµ DOM Content Loaded - Starting whiteboard initialization');
            
            try {
                // Initialize components
                initializeCanvas();
                setupEventListeners();
                loadSessionData();
                
                // Delay Socket.IO initialization to ensure all dependencies are loaded
                setTimeout(() => {
                    console.log('üîµ Delayed Socket.IO initialization');
                    initializeSocketIO();
                }, 500);
            } catch (error) {
                console.error('üî¥ Error during whiteboard initialization:', error);
                showMessage(`Initialization error: ${error.message}`, 'error');
            }
        });

        function initializeSocketIO() {
            try {
                console.log('üîµ Initializing Socket.IO connection');
                
                // Check if Socket.IO client is available
                if (typeof io === 'undefined') {
                    console.error('üî¥ Socket.IO client library not loaded!');
                    showMessage('Socket.IO client library not loaded. Please refresh the page.', 'error');
                    return;
                }
                
                addDebugEvent('Initializing Socket.IO connection');
                
                // Connect to Socket.IO server with enhanced options
                socket = io({
                    transports: ['websocket', 'polling'], // Fallback to polling if WebSocket fails
                    upgrade: true,
                    rememberUpgrade: true,
                    timeout: 20000,
                    forceNew: true
                });
                
                console.log('üîµ Socket.IO client created successfully');
            } catch (error) {
                console.error('üî¥ Error initializing Socket.IO:', error);
                showMessage(`Socket.IO initialization failed: ${error.message}`, 'error');
            }
        }
            
            // Connection event handlers
            socket.on('connect', () => {
                console.log('üîµ Connected to Socket.IO server');
                addDebugEvent('Socket.IO connected');
                isConnected = true;
                lastSocketEvent = 'Connected';
                updateConnectionIndicator('connected');
                
                const joinData = {
                    sessionId: '<%= session._id %>',
                    userId: '<%= user._id %>',
                    userRole: '<%= user.role %>'
                };
                
                console.log('üîµ Joining whiteboard session:', joinData);
                addDebugEvent(`Joining session: ${joinData.sessionId} as ${joinData.userRole}`);
                
                // Join the whiteboard session
                socket.emit('join-whiteboard', joinData);
                
                console.log('üîµ join-whiteboard event emitted');
                addDebugEvent('join-whiteboard event emitted');
                
                // Update debug panel
                updateDebugPanel();
            });

        socket.on('disconnect', (reason) => {
            console.log('üî¥ Disconnected from Socket.IO server:', reason);
            addDebugEvent(`Disconnected: ${reason}`);
            isConnected = false;
            lastSocketEvent = `Disconnected: ${reason}`;
            updateConnectionIndicator('disconnected');
            
            // Attempt reconnection for certain disconnect reasons
            if (reason === 'io server disconnect' || reason === 'io client disconnect') {
                console.log('üîµ Attempting to reconnect...');
                addDebugEvent('Attempting to reconnect...');
                socket.connect();
            }
        });

        socket.on('connect_error', (error) => {
            console.log('üî¥ Socket.IO connection error:', error);
            addDebugEvent(`Connection error: ${error.message}`);
            lastSocketEvent = `Connection error: ${error.message}`;
            updateConnectionIndicator('error');
            
            // Retry connection after delay
            setTimeout(() => {
                if (!isConnected) {
                    console.log('üîµ Retrying connection...');
                    addDebugEvent('Retrying connection...');
                    socket.connect();
                }
            }, 3000);
        });

        socket.on('reconnect', (attemptNumber) => {
            console.log('üîµ Reconnected to Socket.IO server after', attemptNumber, 'attempts');
            addDebugEvent(`Reconnected after ${attemptNumber} attempts`);
            isConnected = true;
            lastSocketEvent = `Reconnected (attempt ${attemptNumber})`;
            updateConnectionIndicator('connected');
            
            // Rejoin session after reconnection
            const joinData = {
                sessionId: '<%= session._id %>',
                userId: '<%= user._id %>',
                userRole: '<%= user.role %>'
            };
            
            socket.emit('join-whiteboard', joinData);
            addDebugEvent('Rejoined session after reconnection');
        });

        socket.on('reconnect_error', (error) => {
            console.log('üî¥ Reconnection error:', error);
            addDebugEvent(`Reconnection error: ${error.message}`);
            lastSocketEvent = `Reconnection error: ${error.message}`;
        });

        socket.on('reconnect_failed', () => {
            console.log('üî¥ Reconnection failed after maximum attempts');
            addDebugEvent('Reconnection failed after maximum attempts');
            lastSocketEvent = 'Reconnection failed';
            updateConnectionIndicator('failed');
        });

            // Listen for whiteboard updates from other users
            socket.on('whiteboard-update', (data) => {
                console.log('üîµ Received whiteboard update:', data);
                addDebugEvent(`Received: ${data.type} from ${data.userId}`);
                lastSocketEvent = `Received: ${data.type}`;
                socketEventsReceived++;
                updateDebugPanel();
                handleRemoteUpdate(data);
            });

            // Listen for user join notifications
            socket.on('user-joined', (data) => {
                console.log('üîµ User joined:', data);
                addDebugEvent(`User joined: ${data.userRole} (${data.userId})`);
                lastSocketEvent = `User joined: ${data.userRole}`;
                socketEventsReceived++;
                updateDebugPanel();
                showMessage(`${data.userRole} joined the session`, 'info');
            });

            // Listen for session room verification
            socket.on('session-verified', (data) => {
                console.log('üîµ Session room verified:', data);
                addDebugEvent(`Session verified: ${data.sessionId}`);
                lastSocketEvent = `Session verified: ${data.sessionId}`;
                socketEventsReceived++;
                updateDebugPanel();
                
                if (data.verified) {
                    showMessage('Successfully joined whiteboard session!', 'success');
                } else {
                    showMessage('Failed to join session. Please refresh.', 'error');
                }
            });

            // Listen for room join confirmation
            socket.on('room-joined', (data) => {
                console.log('üîµ Successfully joined room:', data);
                addDebugEvent(`Room joined: ${data.roomId}`);
                lastSocketEvent = `Room joined: ${data.roomId}`;
                socketEventsReceived++;
                updateDebugPanel();
                
                // Verify we're in the correct session
                if (data.sessionId === '<%= session._id %>') {
                    console.log('üîµ Session ID matches, room join successful');
                    addDebugEvent('Session ID matches, room join successful');
                } else {
                    console.log('üî¥ Session ID mismatch!', { 
                        expected: '<%= session._id %>', 
                        received: data.sessionId 
                    });
                    addDebugEvent(`Session ID mismatch: Expected ${'<%= session._id %>'}, Got ${data.sessionId}`);
                }
            });

            // Listen for connection status updates
            socket.on('connection-status', (data) => {
                console.log('üîµ Connection status update:', data);
                addDebugEvent(`Connection status: ${data.status}`);
                lastSocketEvent = `Status: ${data.status}`;
                socketEventsReceived++;
                updateDebugPanel();
            });
        }

        function handleRemoteUpdate(data) {
            console.log('üîµ handleRemoteUpdate called:', data);
            addDebugEvent(`Remote update received: ${data.type} from ${data.userId}`);
            
            switch (data.type) {
                case 'draw':
                    console.log('üîµ Processing remote draw event:', data.data);
                    addDebugEvent(`Processing remote draw: ${data.data.path ? 'Path found' : 'No path'}`);
                    
                    // Handle remote drawing with enhanced data
                    if (data.data && data.data.path) {
                        console.log('üîµ Creating remote path object');
                        addDebugEvent('Creating remote path object');
                        
                        const path = new fabric.Path(data.data.path, {
                            stroke: data.data.stroke || currentColor,
                            strokeWidth: data.data.strokeWidth || currentSize,
                            fill: data.data.fill || 'transparent',
                            left: data.data.left || 0,
                            top: data.data.top || 0,
                            scaleX: data.data.scaleX || 1,
                            scaleY: data.data.scaleY || 1,
                            selectable: false,
                            evented: false
                        });
                        
                        // Add unique ID for tracking
                        path.id = `remote-${Date.now()}-${Math.random()}`;
                        path.isRemote = true; // Mark as remote object
                        
                        console.log('üîµ Adding remote path to canvas:', path);
                        addDebugEvent(`Adding remote path: ${path.id}`);
                        
                        canvas.add(path);
                        canvas.renderAll();
                        
                        console.log('üîµ Remote drawing added successfully:', path);
                        addDebugEvent(`Remote drawing added: ${path.id}`);
                    } else {
                        console.log('üî¥ Remote draw data missing or invalid:', data.data);
                        addDebugEvent(`Remote draw data invalid: ${JSON.stringify(data.data)}`);
                    }
                    break;
                    
                case 'add-element':
                    // Handle remote element addition
                    if (data.data && data.data.elementType) {
                        addRemoteElement(data.data);
                    }
                    break;
                    
                case 'modify-element':
                    // Handle remote element modification
                    if (data.data && data.data.elementId) {
                        modifyRemoteElement(data.data);
                    }
                    break;
                    
                case 'delete-element':
                    // Handle remote element deletion
                    if (data.data && data.data.elementId) {
                        deleteRemoteElement(data.data.elementId);
                    }
                    break;
                    
                case 'clear':
                    // Handle remote clear
                    canvas.clear();
                    canvas.setBackgroundColor('#ffffff', function() {
                        canvas.renderAll();
                    });
                    break;
                    
                case 'undo-redo':
                    // Handle remote undo/redo
                    if (data.data && data.data.action) {
                        if (data.data.action === 'undo') {
                            undo();
                        } else if (data.data.action === 'redo') {
                            redo();
                        }
                    }
                    break;
            }
        }

        function addRemoteElement(elementData) {
            let element;
            
            switch (elementData.elementType) {
                case 'text':
                    element = new fabric.Textbox(elementData.text, {
                        left: elementData.left,
                        top: elementData.top,
                        fontSize: elementData.fontSize,
                        fill: elementData.fill,
                        selectable: false
                    });
                    break;
                    
                case 'image':
                    fabric.Image.fromURL(elementData.src, (img) => {
                        img.set({
                            left: elementData.left,
                            top: elementData.top,
                            scaleX: elementData.scaleX,
                            scaleY: elementData.scaleY,
                            selectable: false
                        });
                        canvas.add(img);
                        canvas.renderAll();
                    });
                    return;
                    
                case 'shape':
                    if (elementData.shapeType === 'rect') {
                        element = new fabric.Rect({
                            left: elementData.left,
                            top: elementData.top,
                            width: elementData.width,
                            height: elementData.height,
                            fill: elementData.fill,
                            stroke: elementData.stroke,
                            selectable: false
                        });
                    } else if (elementData.shapeType === 'circle') {
                        element = new fabric.Circle({
                            left: elementData.left,
                            top: elementData.top,
                            radius: elementData.radius,
                            fill: elementData.fill,
                            stroke: elementData.stroke,
                            selectable: false
                        });
                    }
                    break;
            }
            
            if (element) {
                canvas.add(element);
                canvas.renderAll();
            }
        }

        function modifyRemoteElement(elementData) {
            // Find and modify the remote element
            const objects = canvas.getObjects();
            for (let obj of objects) {
                if (obj.id === elementData.elementId) {
                    obj.set(elementData.properties);
                    canvas.renderAll();
                    break;
                }
            }
        }

        function deleteRemoteElement(elementId) {
            // Find and delete the remote element
            const objects = canvas.getObjects();
            for (let obj of objects) {
                if (obj.id === elementId) {
                    canvas.remove(obj);
                    canvas.renderAll();
                    break;
                }
            }
        }

        function updateConnectionIndicator(status) {
            const indicator = document.getElementById('connectionIndicator');
            if (indicator) {
                indicator.className = `connection-indicator ${status}`;
                if (status === 'connected') {
                    indicator.innerHTML = '<i class="fas fa-circle"></i> Connected';
                } else if (status === 'disconnected') {
                    indicator.innerHTML = '<i class="fas fa-circle"></i> Disconnected';
                } else {
                    indicator.innerHTML = '<i class="fas fa-circle"></i> Connecting...';
                }
            }
            
            // Update debug panel
            updateDebugPanel();
        }

        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                updateDebugPanel();
            } else {
                panel.style.display = 'none';
            }
        }

        function updateDebugPanel() {
            // Update connection status
            const socketStatus = document.getElementById('debugSocketStatus');
            if (socketStatus) {
                socketStatus.textContent = isConnected ? 'Connected' : 'Disconnected';
                socketStatus.style.color = isConnected ? 'green' : 'red';
            }

            // Update canvas info
            const objectCount = document.getElementById('debugObjectCount');
            if (objectCount && canvas) {
                objectCount.textContent = canvas.getObjects().length;
            }

            const drawingMode = document.getElementById('debugDrawingMode');
            if (drawingMode && canvas) {
                drawingMode.textContent = canvas.isDrawingMode ? 'true' : 'false';
            }

            const currentToolElement = document.getElementById('debugCurrentTool');
            if (currentToolElement) {
                currentToolElement.textContent = currentTool;
            }

            const drawingBrush = document.getElementById('debugDrawingBrush');
            if (drawingBrush && canvas) {
                if (canvas.freeDrawingBrush) {
                    drawingBrush.textContent = `Color: ${canvas.freeDrawingBrush.color}, Width: ${canvas.freeDrawingBrush.width}`;
                } else {
                    drawingBrush.textContent = 'Not initialized';
                }
            }

            const canvasSize = document.getElementById('debugCanvasSize');
            if (canvasSize && canvas) {
                canvasSize.textContent = `${canvas.width}x${canvas.height}`;
            }

            // Update Socket.IO status
            const socketId = document.getElementById('debugSocketId');
            if (socketId && socket) {
                socketId.textContent = socket.id || 'Unknown';
            }

            const sessionRoom = document.getElementById('debugSessionRoom');
            if (sessionRoom) {
                sessionRoom.textContent = '<%= session._id %>';
            }

            const lastEvent = document.getElementById('debugLastEvent');
            if (lastEvent) {
                lastEvent.textContent = lastSocketEvent || 'None';
            }

            const eventsSent = document.getElementById('debugEventsSent');
            if (eventsSent) {
                eventsSent.textContent = socketEventsSent || 0;
            }

            const eventsReceived = document.getElementById('debugEventsReceived');
            if (eventsReceived) {
                eventsReceived.textContent = socketEventsReceived || 0;
            }

            // Update network status
            const latency = document.getElementById('debugLatency');
            if (latency) {
                latency.textContent = networkLatency ? `${networkLatency}ms` : 'Unknown';
            }

            const quality = document.getElementById('debugQuality');
            if (quality) {
                quality.textContent = connectionQuality;
                quality.style.color = connectionQuality === 'Excellent' ? 'green' : 
                                   connectionQuality === 'Good' ? 'blue' : 
                                   connectionQuality === 'Fair' ? 'orange' : 
                                   connectionQuality === 'Poor' ? 'red' : 'black';
            }

            const monitoring = document.getElementById('debugMonitoring');
            if (monitoring) {
                monitoring.textContent = pingInterval ? 'Active' : 'Stopped';
                monitoring.style.color = pingInterval ? 'green' : 'red';
            }

            const lastPing = document.getElementById('debugLastPing');
            if (lastPing) {
                lastPing.textContent = lastPingTime ? new Date(lastPingTime).toLocaleTimeString() : 'Never';
            }
        }

        function addDebugEvent(message) {
            const eventsContainer = document.getElementById('debugEvents');
            if (eventsContainer) {
                const timestamp = new Date().toLocaleTimeString();
                const eventElement = document.createElement('p');
                eventElement.textContent = `[${timestamp}] ${message}`;
                eventsContainer.appendChild(eventElement);
                
                // Keep only last 20 events
                if (eventsContainer.children.length > 20) {
                    eventsContainer.removeChild(eventsContainer.firstChild);
                }
                
                // Auto-scroll to bottom
                eventsContainer.scrollTop = eventsContainer.scrollHeight;
            }
        }

        function testRealTimeSync() {
            if (!isConnected || !socket) {
                addDebugEvent('Test failed: Socket not connected');
                return;
            }

            // Test drawing event
            const testPath = new fabric.Path('M 10 10 L 100 100', {
                stroke: 'red',
                strokeWidth: 3,
                selectable: false,
                evented: false
            });
            
            canvas.add(testPath);
            canvas.renderAll();
            
            // Emit test event
            socket.emit('whiteboard-draw', {
                sessionId: '<%= session._id %>',
                userId: '<%= user._id %>',
                drawingData: {
                    path: 'M 10 10 L 100 100',
                    stroke: 'red',
                    strokeWidth: 3,
                    fill: 'transparent'
                }
            });
            
            addDebugEvent('Test sync event sent');
            showMessage('Test sync event sent!', 'success');
        }

        function testDrawing() {
            console.log('üîµ Test drawing function called');
            addDebugEvent('Test drawing function called');
            
            // Test if drawing mode works
            console.log('üîµ Current drawing mode:', canvas.isDrawingMode);
            console.log('üîµ Current tool:', currentTool);
            console.log('üîµ Canvas objects count:', canvas.getObjects().length);
            
            addDebugEvent(`Drawing mode: ${canvas.isDrawingMode}, Tool: ${currentTool}, Objects: ${canvas.getObjects().length}`);
            
            // Try to enable drawing mode
            if (currentTool === 'pen') {
                canvas.isDrawingMode = true;
                console.log('üîµ Drawing mode enabled');
                addDebugEvent('Drawing mode enabled');
                
                // Test drawing a simple path
                const testPath = new fabric.Path('M 50 50 L 150 150', {
                    stroke: 'blue',
                    strokeWidth: 5,
                    selectable: false,
                    evented: false
                });
                
                console.log('üîµ Test path created:', testPath);
                addDebugEvent('Test path created');
                
                canvas.add(testPath);
                canvas.renderAll();
                
                console.log('üîµ Test path added to canvas');
                addDebugEvent('Test path added to canvas');
                
                // Try to emit this as a drawing event
                if (isConnected && socket) {
                    console.log('üîµ Emitting test drawing event');
                    emitCanvasUpdate('draw', testPath);
                } else {
                    console.log('üî¥ Cannot emit: Socket not ready');
                    addDebugEvent('Cannot emit test drawing: Socket not ready');
                }
            } else {
                console.log('üî¥ Current tool is not pen:', currentTool);
                addDebugEvent(`Current tool is not pen: ${currentTool}`);
                
                // Switch to pen tool
                setTool('pen');
                console.log('üîµ Switched to pen tool');
                addDebugEvent('Switched to pen tool');
                
                // Try drawing again
                setTimeout(() => {
                    testDrawing();
                }, 100);
            }
        }

        function forceDrawingMode() {
            console.log('üîµ Force drawing mode function called');
            addDebugEvent('Force drawing mode called');
            
            // Force enable drawing mode
            canvas.isDrawingMode = true;
            currentTool = 'pen';
            
            // Ensure drawing brush is ready
            if (!canvas.freeDrawingBrush) {
                console.log('üîµ Creating freeDrawingBrush');
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                addDebugEvent('FreeDrawingBrush created');
            }
            
            // Update brush settings
            canvas.freeDrawingBrush.color = currentColor;
            canvas.freeDrawingBrush.width = currentSize;
            
            // Update UI
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('[data-tool="pen"]').classList.add('active');
            
            console.log('üîµ Drawing mode forced enabled');
            addDebugEvent('Drawing mode forced enabled');
            
            // Update debug panel
            updateDebugPanel();
            
            showMessage('Drawing mode forced enabled! Try drawing now.', 'success');
        }

        function testCompleteFlow() {
            console.log('üîµ Testing complete real-time flow');
            addDebugEvent('Testing complete real-time flow');
            
            // Step 1: Check connection
            if (!isConnected || !socket) {
                console.log('üî¥ Step 1 FAILED: Socket not connected');
                addDebugEvent('Step 1 FAILED: Socket not connected');
                showMessage('Socket not connected!', 'error');
                return;
            }
            console.log('üîµ Step 1 PASSED: Socket connected');
            addDebugEvent('Step 1 PASSED: Socket connected');
            
            // Step 2: Check drawing mode
            if (!canvas.isDrawingMode) {
                console.log('üî¥ Step 2 FAILED: Drawing mode not enabled');
                addDebugEvent('Step 2 FAILED: Drawing mode not enabled');
                forceDrawingMode();
                setTimeout(() => testCompleteFlow(), 200);
                return;
            }
            console.log('üîµ Step 2 PASSED: Drawing mode enabled');
            addDebugEvent('Step 2 PASSED: Drawing mode enabled');
            
            // Step 3: Create test drawing
            console.log('üîµ Step 3: Creating test drawing');
            addDebugEvent('Step 3: Creating test drawing');
            
            const testPath = new fabric.Path('M 100 100 L 200 200', {
                stroke: 'red',
                strokeWidth: 5,
                selectable: false,
                evented: false
            });
            
            // Add to canvas
            canvas.add(testPath);
            canvas.renderAll();
            
            console.log('üîµ Test drawing added to canvas');
            addDebugEvent('Test drawing added to canvas');
            
            // Step 4: Emit drawing event
            setTimeout(() => {
                console.log('üîµ Step 4: Emitting drawing event');
                addDebugEvent('Step 4: Emitting drawing event');
                
                if (isConnected && socket) {
                    emitCanvasUpdate('draw', testPath);
                    console.log('üîµ Drawing event emitted successfully');
                    addDebugEvent('Drawing event emitted successfully');
                    
                    showMessage('Complete flow test completed! Check debug panel for results.', 'success');
                } else {
                    console.log('üî¥ Step 4 FAILED: Socket disconnected during test');
                    addDebugEvent('Step 4 FAILED: Socket disconnected during test');
                }
            }, 500);
        }

        function testSocketConnection() {
            console.log('üîµ Testing Socket.IO connection');
            addDebugEvent('Testing Socket.IO connection');
            
            if (!socket) {
                console.log('üî¥ No socket object');
                addDebugEvent('No socket object');
                showMessage('No socket object!', 'error');
                return;
            }
            
            console.log('üîµ Socket object exists:', socket);
            addDebugEvent('Socket object exists');
            
            if (!isConnected) {
                console.log('üî¥ Socket not connected');
                addDebugEvent('Socket not connected');
                showMessage('Socket not connected!', 'error');
                return;
            }
            
            console.log('üîµ Socket connected, ID:', socket.id);
            addDebugEvent(`Socket connected, ID: ${socket.id}`);
            
            // Test emit
            const testData = {
                sessionId: '<%= session._id %>',
                userId: '<%= user._id %>',
                test: true,
                timestamp: Date.now()
            };
            
            console.log('üîµ Emitting test event:', testData);
            addDebugEvent('Emitting test event');
            
            socket.emit('test-connection', testData);
            
            console.log('üîµ Test event emitted');
            addDebugEvent('Test event emitted');
            
            showMessage('Socket connection test completed!', 'success');
        }

        function verifySessionRoom() {
            console.log('üîµ Verifying session room');
            addDebugEvent('Verifying session room');
            
            if (!isConnected || !socket) {
                console.log('üî¥ Cannot verify: Socket not connected');
                addDebugEvent('Cannot verify: Socket not connected');
                showMessage('Socket not connected!', 'error');
                return;
            }
            
            // Request session verification
            const verifyData = {
                sessionId: '<%= session._id %>',
                userId: '<%= user._id %>',
                userRole: '<%= user.role %>',
                timestamp: Date.now()
            };
            
            console.log('üîµ Requesting session verification:', verifyData);
            addDebugEvent('Requesting session verification');
            
            socket.emit('verify-session', verifyData);
            
            // Also emit a test drawing to verify room communication
            setTimeout(() => {
                if (isConnected) {
                    console.log('üîµ Testing room communication with test drawing');
                    addDebugEvent('Testing room communication');
                    
                    const testPath = new fabric.Path('M 10 10 L 50 50', {
                        stroke: 'green',
                        strokeWidth: 3,
                        selectable: false,
                        evented: false
                    });
                    
                    canvas.add(testPath);
                    canvas.renderAll();
                    
                    emitCanvasUpdate('draw', testPath);
                    
                    showMessage('Session verification and room communication test sent!', 'success');
                }
            }, 1000);
        }

        function startNetworkMonitoring() {
            console.log('üîµ Starting network monitoring');
            addDebugEvent('Starting network monitoring');
            
            // Start ping interval
            pingInterval = setInterval(() => {
                if (isConnected && socket) {
                    const pingData = {
                        sessionId: '<%= session._id %>',
                        userId: '<%= user._id %>',
                        timestamp: Date.now()
                    };
                    
                    lastPingTime = Date.now();
                    socket.emit('ping', pingData);
                }
            }, 5000); // Ping every 5 seconds
            
            // Listen for pong responses
            socket.on('pong', (data) => {
                const latency = Date.now() - lastPingTime;
                networkLatency = latency;
                
                // Determine connection quality
                if (latency < 100) {
                    connectionQuality = 'Excellent';
                } else if (latency < 300) {
                    connectionQuality = 'Good';
                } else if (latency < 500) {
                    connectionQuality = 'Fair';
                } else {
                    connectionQuality = 'Poor';
                }
                
                console.log('üîµ Network ping response:', { latency, quality: connectionQuality });
                addDebugEvent(`Network ping: ${latency}ms (${connectionQuality})`);
                
                // Update debug panel
                updateDebugPanel();
            });
        }

        function stopNetworkMonitoring() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
                console.log('üîµ Network monitoring stopped');
                addDebugEvent('Network monitoring stopped');
            }
        }

        function toggleNetworkMonitoring() {
            if (pingInterval) {
                stopNetworkMonitoring();
                showMessage('Network monitoring stopped', 'info');
            } else {
                startNetworkMonitoring();
                showMessage('Network monitoring started', 'success');
            }
        }

        function retrySocketIO() {
            console.log('üîµ Retrying Socket.IO initialization');
            addDebugEvent('Retrying Socket.IO initialization');
            
            // Stop existing monitoring
            stopNetworkMonitoring();
            
            // Reset connection state
            isConnected = false;
            lastSocketEvent = 'Retrying...';
            updateConnectionIndicator('connecting');
            
            // Try to reinitialize
            try {
                if (socket) {
                    socket.disconnect();
                    socket = null;
                }
                
                // Wait a moment then retry
                setTimeout(() => {
                    initializeSocketIO();
                }, 1000);
                
                showMessage('Socket.IO reinitialization started...', 'info');
            } catch (error) {
                console.error('üî¥ Error retrying Socket.IO:', error);
                addDebugEvent(`Retry error: ${error.message}`);
                showMessage(`Retry failed: ${error.message}`, 'error');
            }
        }

        function checkServerStatus() {
            console.log('üîµ Checking server status');
            addDebugEvent('Checking server status');
            
            // Check if Socket.IO client is available
            if (typeof io === 'undefined') {
                console.log('üî¥ Socket.IO client not available');
                addDebugEvent('Socket.IO client not available');
                showMessage('Socket.IO client not available', 'error');
                return;
            }
            
            // Check if we can reach the server
            fetch('/api/health')
                .then(response => {
                    if (response.ok) {
                        console.log('üîµ Server health check passed');
                        addDebugEvent('Server health check passed');
                        showMessage('Server is healthy', 'success');
                    } else {
                        console.log('üî¥ Server health check failed:', response.status);
                        addDebugEvent(`Server health check failed: ${response.status}`);
                        showMessage(`Server health check failed: ${response.status}`, 'error');
                    }
                })
                .catch(error => {
                    console.log('üî¥ Server health check error:', error);
                    addDebugEvent(`Server health check error: ${error.message}`);
                    showMessage(`Server health check error: ${error.message}`, 'error');
                });
        }

        // Simple message display function
        function showMessage(message, type = 'info') {
            console.log(`üîµ Message [${type}]:`, message);
            
            // Create a simple message element
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                max-width: 300px;
                word-wrap: break-word;
            `;
            
            // Set background color based on type
            switch(type) {
                case 'success':
                    messageDiv.style.backgroundColor = '#10B981';
                    break;
                case 'error':
                    messageDiv.style.backgroundColor = '#EF4444';
                    break;
                case 'warning':
                    messageDiv.style.backgroundColor = '#F59E0B';
                    break;
                default:
                    messageDiv.style.backgroundColor = '#3B82F6';
            }
            
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // Simple debug event function
        function addDebugEvent(message) {
            console.log(`üîµ Debug: ${message}`);
            
            // Try to update debug panel if it exists
            try {
                const eventsContainer = document.getElementById('debugEvents');
                if (eventsContainer) {
                    const timestamp = new Date().toLocaleTimeString();
                    const eventElement = document.createElement('p');
                    eventElement.textContent = `[${timestamp}] ${message}`;
                    eventsContainer.appendChild(eventElement);
                    
                    // Keep only last 20 events
                    if (eventsContainer.children.length > 20) {
                        eventsContainer.removeChild(eventsContainer.firstChild);
                    }
                    
                    // Auto-scroll to bottom
                    eventsContainer.scrollTop = eventsContainer.scrollHeight;
                }
            } catch (error) {
                console.log('üî¥ Debug panel update failed:', error);
            }
        }

        // Simple connection indicator function
        function updateConnectionIndicator(status) {
            console.log(`üîµ Connection indicator updated: ${status}`);
            
            try {
                const indicator = document.getElementById('connectionIndicator');
                if (indicator) {
                    indicator.className = `connection-indicator ${status}`;
                    if (status === 'connected') {
                        indicator.innerHTML = '<i class="fas fa-circle"></i> Connected';
                    } else if (status === 'disconnected') {
                        indicator.innerHTML = '<i class="fas fa-circle"></i> Disconnected';
                    } else {
                        indicator.innerHTML = '<i class="fas fa-circle"></i> Connecting...';
                    }
                }
            } catch (error) {
                console.log('üî¥ Connection indicator update failed:', error);
            }
        }

        // Simple debug panel update function
        function updateDebugPanel() {
            console.log('üîµ Updating debug panel');
            
            try {
                // Update connection status
                const socketStatus = document.getElementById('debugSocketStatus');
                if (socketStatus) {
                    socketStatus.textContent = isConnected ? 'Connected' : 'Disconnected';
                    socketStatus.style.color = isConnected ? 'green' : 'red';
                }

                // Update canvas info
                const objectCount = document.getElementById('debugObjectCount');
                if (objectCount && canvas) {
                    objectCount.textContent = canvas.getObjects().length;
                }

                const drawingMode = document.getElementById('debugDrawingMode');
                if (drawingMode && canvas) {
                    drawingMode.textContent = canvas.isDrawingMode ? 'true' : 'false';
                }

                const currentToolElement = document.getElementById('debugCurrentTool');
                if (currentToolElement) {
                    currentToolElement.textContent = currentTool;
                }
            } catch (error) {
                console.log('üî¥ Debug panel update failed:', error);
            }
        }

        // Simple session data loader
        function loadSessionData() {
            console.log('üîµ Loading session data');
            addDebugEvent('Loading session data');
            
            try {
                // Basic session info
                console.log('üîµ Session ID:', '<%= session._id %>');
                console.log('üîµ User ID:', '<%= user._id %>');
                console.log('üîµ User Role:', '<%= user.role %>');
                
                addDebugEvent('Session data loaded successfully');
            } catch (error) {
                console.error('üî¥ Error loading session data:', error);
                addDebugEvent(`Session data error: ${error.message}`);
            }
        }

        // Simple event listeners setup
        function setupEventListeners() {
            console.log('üîµ Setting up event listeners');
            addDebugEvent('Setting up event listeners');
            
            try {
                // Color picker
                const colorPicker = document.getElementById('colorPicker');
                if (colorPicker) {
                    colorPicker.addEventListener('change', function(e) {
                        currentColor = e.target.value;
                        console.log('üîµ Color changed to:', currentColor);
                        addDebugEvent(`Color changed to: ${currentColor}`);
                    });
                }
                
                // Size slider
                const sizeSlider = document.getElementById('sizeSlider');
                if (sizeSlider) {
                    sizeSlider.addEventListener('change', function(e) {
                        currentSize = parseInt(e.target.value);
                        console.log('üîµ Size changed to:', currentSize);
                        addDebugEvent(`Size changed to: ${currentSize}`);
                        
                        const sizeValue = document.getElementById('sizeValue');
                        if (sizeValue) {
                            sizeValue.textContent = currentSize;
                        }
                    });
                }
                
                addDebugEvent('Event listeners setup completed');
            } catch (error) {
                console.error('üî¥ Error setting up event listeners:', error);
                addDebugEvent(`Event listeners error: ${error.message}`);
            }
        }

        function emitCanvasUpdate(type, object) {
            console.log('üîµ emitCanvasUpdate called:', { type, object, isConnected, hasSocket: !!socket });
            addDebugEvent(`emitCanvasUpdate called: ${type}`);
            
            if (!isConnected || !socket) {
                console.log('üî¥ Cannot emit: Socket not ready', { isConnected, socket: !!socket });
                addDebugEvent(`Cannot emit: ${type} - Socket not connected`);
                return;
            }
            
            const sessionId = '<%= session._id %>';
            const userId = '<%= user._id %>';
            
            console.log('üîµ Emitting event:', { type, sessionId, userId });
            addDebugEvent(`Emitting: ${type} to session ${sessionId}`);
            
            switch (type) {
                case 'draw':
                    // Enhanced drawing data capture
                    const drawingData = {
                        path: object.path,
                        stroke: object.stroke || currentColor,
                        strokeWidth: object.strokeWidth || currentSize,
                        fill: object.fill || 'transparent',
                        left: object.left,
                        top: object.top,
                        scaleX: object.scaleX || 1,
                        scaleY: object.scaleY || 1
                    };
                    
                    console.log('üîµ Drawing data prepared:', drawingData);
                    addDebugEvent(`Drawing data: ${JSON.stringify(drawingData).substring(0, 100)}...`);
                    
                    const drawEvent = {
                        sessionId,
                        userId,
                        drawingData
                    };
                    
                    console.log('üîµ Emitting whiteboard-draw event:', drawEvent);
                    socket.emit('whiteboard-draw', drawEvent);
                    
                    // Verify emission
                    console.log('üîµ whiteboard-draw event emitted successfully');
                    addDebugEvent('whiteboard-draw event emitted successfully');
                    lastSocketEvent = 'Sent: whiteboard-draw';
                    socketEventsSent++;
                    updateDebugPanel();
                    break;
                    
                case 'add-element':
                    console.log('üîµ Preparing add-element data for:', object.type);
                    addDebugEvent(`Preparing add-element: ${object.type}`);
                    
                    const elementData = {
                        elementType: object.type,
                        left: object.left,
                        top: object.top,
                        fill: object.fill,
                        stroke: object.stroke
                    };
                    
                    if (object.type === 'textbox') {
                        elementData.elementType = 'text';
                        elementData.text = object.text;
                        elementData.fontSize = object.fontSize;
                    } else if (object.type === 'image') {
                        elementData.elementType = 'image';
                        elementData.src = object.src;
                        elementData.scaleX = object.scaleX;
                        elementData.scaleY = object.scaleY;
                    } else if (object.type === 'rect') {
                        elementData.elementType = 'shape';
                        elementData.shapeType = 'rect';
                        elementData.width = object.width;
                        elementData.height = object.height;
                    } else if (object.type === 'circle') {
                        elementData.elementType = 'shape';
                        elementData.shapeType = 'circle';
                        elementData.radius = object.radius;
                    }
                    
                    console.log('üîµ Element data prepared:', elementData);
                    addDebugEvent(`Element data: ${JSON.stringify(elementData).substring(0, 100)}...`);
                    
                    socket.emit('whiteboard-add-element', {
                        sessionId,
                        userId,
                        elementData
                    });
                    
                    console.log('üîµ whiteboard-add-element event emitted successfully');
                    addDebugEvent('whiteboard-add-element event emitted successfully');
                    break;
                    
                case 'modify-element':
                    socket.emit('whiteboard-modify-element', {
                        sessionId,
                        userId,
                        elementData: {
                            elementId: object.id,
                            properties: {
                                left: object.left,
                                top: object.top,
                                scaleX: object.scaleX,
                                scaleY: object.scaleY,
                                angle: object.angle,
                                fill: object.fill,
                                stroke: object.stroke
                            }
                        }
                    });
                    break;
                    
                case 'delete-element':
                    socket.emit('whiteboard-delete-element', {
                        sessionId,
                        userId,
                        elementId: object.id
                    });
                    break;
            }
        }

        function initializeCanvas() {
            console.log('üîµ Starting canvas initialization...');
            addDebugEvent('Starting canvas initialization');
            
            try {
                // Check if canvas element exists
                const canvasElement = document.getElementById('whiteboard-canvas');
                if (!canvasElement) {
                    throw new Error('Canvas element not found');
                }
                
                console.log('üîµ Canvas element found, creating Fabric.js canvas');
                addDebugEvent('Canvas element found');
                
                // Create Fabric.js canvas
                canvas = new fabric.Canvas('whiteboard-canvas', {
                    isDrawingMode: false,
                    selection: true
                });
                
                console.log('üîµ Fabric.js canvas created successfully');
                addDebugEvent('Fabric.js canvas created');
                
                // Initialize drawing brush
                if (!canvas.freeDrawingBrush) {
                    console.log('üîµ Creating freeDrawingBrush');
                    canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                    addDebugEvent('FreeDrawingBrush created');
                }
                
                // Set initial brush properties
                canvas.freeDrawingBrush.color = currentColor;
                canvas.freeDrawingBrush.width = currentSize;
                
                console.log('üîµ Drawing brush configured');
                addDebugEvent('Drawing brush configured');
                
                // Set canvas background
                canvas.setBackgroundColor('#ffffff', function() {
                    canvas.renderAll();
                    console.log('üîµ Canvas background set');
                });
                
                // Set initial dimensions
                resizeCanvas();
                
                // Set default tool to pen for teachers
                <% if (isTeacher) { %>
                setTimeout(() => {
                    console.log('üîµ Setting default pen tool for teacher');
                    setTool('pen');
                }, 200);
                <% } %>
                
                console.log('üîµ Canvas initialization completed successfully');
                addDebugEvent('Canvas initialization completed');
                showMessage('Canvas initialized successfully!', 'success');
                
            } catch (error) {
                console.error('üî¥ Canvas initialization failed:', error);
                addDebugEvent(`Canvas initialization failed: ${error.message}`);
                showMessage(`Canvas initialization failed: ${error.message}`, 'error');
            }
        }

        function setupEventListeners() {
            console.log('üîµ Setting up event listeners...');
            addDebugEvent('Setting up event listeners');
            
            try {
                // Tool buttons
                const toolButtons = document.querySelectorAll('.tool-btn');
                console.log('üîµ Found tool buttons:', toolButtons.length);
                
                toolButtons.forEach(btn => {
                    const tool = btn.getAttribute('data-tool');
                    console.log('üîµ Setting up tool button:', tool);
                    
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        console.log('üîµ Tool button clicked:', tool);
                        setTool(tool);
                    });
                });
                
                // Color picker
                const colorPicker = document.getElementById('colorPicker');
                if (colorPicker) {
                    colorPicker.addEventListener('change', function(e) {
                        currentColor = e.target.value;
                        console.log('üîµ Color changed to:', currentColor);
                        updateCanvasSettings();
                    });
                    console.log('üîµ Color picker event listener added');
                } else {
                    console.log('üî¥ Color picker not found');
                }

                // Size slider
                const sizeSlider = document.getElementById('sizeSlider');
                if (sizeSlider) {
                    sizeSlider.addEventListener('change', function(e) {
                        currentSize = parseInt(e.target.value);
                        const sizeValue = document.getElementById('sizeValue');
                        if (sizeValue) {
                            sizeValue.textContent = currentSize;
                        }
                        console.log('üîµ Size changed to:', currentSize);
                        updateCanvasSettings();
                    });
                    console.log('üîµ Size slider event listener added');
                } else {
                    console.log('üî¥ Size slider not found');
                }

                // Window resize
                window.addEventListener('resize', resizeCanvas);
                console.log('üîµ Window resize event listener added');

                // Auto-save every 30 seconds
                setInterval(autoSave, 30000);
                console.log('üîµ Auto-save interval set');
                
                addDebugEvent('Event listeners setup completed');
                console.log('üîµ All event listeners setup completed');
                
            } catch (error) {
                console.error('üî¥ Error setting up event listeners:', error);
                addDebugEvent(`Event listeners error: ${error.message}`);
            }
        }

        // Simple auto-save function
        function autoSave() {
            try {
                if (canvas && canvas.getObjects().length > 0) {
                    console.log('üîµ Auto-saving canvas...');
                    addDebugEvent('Auto-saving canvas');
                    // For now, just log the save
                    lastSaveTime = Date.now();
                }
            } catch (error) {
                console.log('üî¥ Auto-save failed:', error);
            }
        }

        // Test function to verify canvas is working
        function testCanvas() {
            console.log('üîµ Testing canvas functionality...');
            addDebugEvent('Testing canvas functionality');
            
            try {
                if (!canvas) {
                    throw new Error('Canvas not initialized');
                }
                
                // Test drawing a simple line
                const line = new fabric.Line([50, 50, 200, 200], {
                    stroke: 'red',
                    strokeWidth: 5
                });
                
                canvas.add(line);
                canvas.renderAll();
                
                console.log('üîµ Test line added successfully');
                addDebugEvent('Test line added successfully');
                showMessage('Canvas test successful!', 'success');
                
            } catch (error) {
                console.error('üî¥ Canvas test failed:', error);
                addDebugEvent(`Canvas test failed: ${error.message}`);
                showMessage(`Canvas test failed: ${error.message}`, 'error');
            }
        }

        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            canvas.setWidth(containerWidth);
            canvas.setHeight(containerHeight);
            canvas.renderAll();
        }

        function setTool(tool) {
            console.log('üîµ setTool called:', tool);
            addDebugEvent(`Tool changed to: ${tool}`);
            
            currentTool = tool;
            
            // Update active button (find by data-tool attribute)
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-tool') === tool) {
                    btn.classList.add('active');
                }
            });

            // Configure canvas based on tool
            switch(tool) {
                case 'select':
                    console.log('üîµ Setting select tool');
                    if (canvas) {
                        canvas.isDrawingMode = false;
                        canvas.selection = true;
                    }
                    break;
                case 'pen':
                    console.log('üîµ Setting pen tool - Initializing drawing mode');
                    addDebugEvent('Initializing pen tool and drawing mode');
                    
                    if (canvas) {
                        canvas.isDrawingMode = true;
                        canvas.selection = false;
                        
                        // Ensure freeDrawingBrush exists
                        if (!canvas.freeDrawingBrush) {
                            console.log('üîµ Creating freeDrawingBrush');
                            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                            addDebugEvent('FreeDrawingBrush created');
                        }
                        
                        updateCanvasSettings();
                        console.log('üîµ Drawing mode enabled:', canvas.isDrawingMode);
                        console.log('üîµ Free drawing brush:', canvas.freeDrawingBrush);
                    }
                    break;
                default:
                    console.log('üîµ Unknown tool:', tool);
                    break;
            }
            
            addDebugEvent(`Drawing mode: ${canvas ? canvas.isDrawingMode : 'N/A'}, Brush: ${canvas && canvas.freeDrawingBrush ? 'Ready' : 'Failed'}`);
        }
                case 'eraser':
                    console.log('üîµ Setting eraser tool');
                    canvas.isDrawingMode = true;
                    canvas.selection = false;
                    if (canvas.freeDrawingBrush) {
                        canvas.freeDrawingBrush.color = '#ffffff';
                        canvas.freeDrawingBrush.width = currentSize * 2;
                    }
                    break;
                case 'text':
                    console.log('üîµ Setting text tool');
                    canvas.isDrawingMode = false;
                    canvas.selection = true;
                    break;
                case 'shape':
                    console.log('üîµ Setting shape tool');
                    canvas.isDrawingMode = false;
                    canvas.selection = true;
                    break;
            }
            
            // Update debug panel
            updateDebugPanel();
        }

        function updateCanvasSettings() {
            console.log('üîµ updateCanvasSettings called');
            addDebugEvent('Canvas settings updated');
            
            if (canvas.isDrawingMode) {
                console.log('üîµ Updating drawing brush settings:', { color: currentColor, width: currentSize });
                addDebugEvent(`Brush settings: Color=${currentColor}, Width=${currentSize}`);
                
                if (canvas.freeDrawingBrush) {
                    canvas.freeDrawingBrush.color = currentColor;
                    canvas.freeDrawingBrush.width = currentSize;
                    console.log('üîµ Drawing brush settings updated successfully');
                    addDebugEvent('Drawing brush settings updated successfully');
                } else {
                    console.log('üî¥ No freeDrawingBrush available');
                    addDebugEvent('No freeDrawingBrush available');
                }
            } else {
                console.log('üî¥ Canvas not in drawing mode');
                addDebugEvent('Canvas not in drawing mode');
            }
        }

        function clearCanvas() {
            if (confirm('Are you sure you want to clear the entire canvas?')) {
                saveToUndoStack();
                canvas.clear();
                canvas.setBackgroundColor('#ffffff', function() {
                    canvas.renderAll();
                });
                
                // Emit clear event
                if (isConnected && socket) {
                    socket.emit('whiteboard-clear', {
                        sessionId: '<%= session._id %>',
                        userId: '<%= user._id %>'
                    });
                }
            }
        }

        function undo() {
            if (undoStack.length > 0) {
                const currentState = canvas.toJSON();
                redoStack.push(currentState);
                
                const previousState = undoStack.pop();
                canvas.loadFromJSON(previousState, function() {
                    canvas.renderAll();
                });
                
                // Emit undo event
                if (isConnected && socket) {
                    socket.emit('whiteboard-undo-redo', {
                        sessionId: '<%= session._id %>',
                        userId: '<%= user._id %>',
                        action: 'undo'
                    });
                }
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                const currentState = canvas.toJSON();
                undoStack.push(currentState);
                
                const nextState = redoStack.pop();
                canvas.loadFromJSON(nextState, function() {
                    canvas.renderAll();
                });
                
                // Emit redo event
                if (isConnected && socket) {
                    socket.emit('whiteboard-undo-redo', {
                        sessionId: '<%= session._id %>',
                        userId: '<%= user._id %>',
                        action: 'redo'
                    });
                }
            }
        }

        function saveToUndoStack() {
            const currentState = canvas.toJSON();
            undoStack.push(currentState);
            
            // Limit undo stack size
            if (undoStack.length > 20) {
                undoStack.shift();
            }
            
            // Clear redo stack when new action is performed
            redoStack = [];
        }

        function addMathEquation() {
            const mathInput = document.getElementById('mathInput');
            const equation = mathInput.value.trim();
            
            if (!equation) return;

            const textbox = new fabric.Textbox('\\(' + equation + '\\)', {
                left: 100,
                top: 100,
                fontSize: 20,
                fill: currentColor,
                fontFamily: 'serif'
            });

            canvas.add(textbox);
            canvas.setActiveObject(textbox);
            canvas.renderAll();
            
            // Render MathJax
            MathJax.typesetPromise([textbox.element]).then(() => {
                canvas.renderAll();
            });

            mathInput.value = '';
            saveToUndoStack();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                if (file.type.startsWith('image/')) {
                    fabric.Image.fromURL(e.target.result, function(img) {
                        img.scaleToWidth(400);
                        canvas.add(img);
                        canvas.renderAll();
                        saveToUndoStack();
                    });
                } else {
                    // For PDFs and other files, show message
                    alert('File uploaded successfully! You can now reference it during your session.');
                }
            };
            reader.readAsDataURL(file);
        }

        function takeSnapshot() {
            const snapshotName = prompt('Enter snapshot name:');
            if (!snapshotName) return;

            const dataURL = canvas.toDataURL('image/png');
            
            // Save snapshot to server
            fetch(`/api/whiteboard/<%= session._id %>/snapshot`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    pageNumber: 1,
                    name: snapshotName,
                    description: 'Canvas snapshot'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage('Snapshot saved successfully!', 'success');
                } else {
                    showMessage('Failed to save snapshot: ' + data.error, 'error');
                }
            })
            .catch(error => {
                showMessage('Error saving snapshot: ' + error.message, 'error');
            });
        }

        function exportSession() {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = '<%= session.title %>-whiteboard.png';
            link.href = dataURL;
            link.click();
        }

        function pauseSession() {
            updateSessionStatus('paused');
        }

        function resumeSession() {
            updateSessionStatus('active');
        }

        function endSession() {
            if (confirm('Are you sure you want to end this session? This action cannot be undone.')) {
                updateSessionStatus('ended');
            }
        }

        async function updateSessionStatus(status) {
            try {
                const response = await fetch(`/api/whiteboard/<%= session._id %>/status`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ status })
                });

                if (response.ok) {
                    if (status === 'paused') {
                        document.getElementById('pauseBtn').style.display = 'none';
                        document.getElementById('resumeBtn').style.display = 'inline-flex';
                        showMessage('Session paused', 'success');
                    } else if (status === 'active') {
                        document.getElementById('pauseBtn').style.display = 'inline-flex';
                        document.getElementById('resumeBtn').style.display = 'none';
                        showMessage('Session resumed', 'success');
                    } else if (status === 'ended') {
                        showMessage('Session ended. Redirecting...', 'success');
                        setTimeout(() => {
                            window.location.href = '/whiteboard';
                        }, 2000);
                    }
                } else {
                    const error = await response.json();
                    showMessage('Error: ' + error.error, 'error');
                }
            } catch (error) {
                console.error('Error updating session status:', error);
                showMessage('Failed to update session status', 'error');
            }
        }

        function loadSessionData() {
            // Load existing board content if any
            <% if (session.boardContent && session.boardContent.pages && session.boardContent.pages.length > 0) { %>
                const pageData = <%- JSON.stringify(session.boardContent.pages[0]) %>;
                if (pageData.elements && pageData.elements.length > 0) {
                    // Load elements from session data
                    pageData.elements.forEach(element => {
                        // Recreate fabric objects from saved data
                        // This is a simplified version - you'd need more complex logic for full reconstruction
                    });
                }
            <% } %>
        }

        function autoSave() {
            const currentTime = Date.now();
            if (currentTime - lastSaveTime > 30000) { // 30 seconds
                saveToUndoStack();
                lastSaveTime = currentTime;
                console.log('Auto-saved whiteboard state');
            }
        }

        function showMessage(message, type) {
            // Create message element
            const messageDiv = document.createElement('div');
            messageDiv.className = `${type}-message`;
            messageDiv.textContent = message;
            
            // Insert at top of canvas container
            const container = document.querySelector('.canvas-container');
            container.insertBefore(messageDiv, container.firstChild);
            
            // Remove after 3 seconds
            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        // Canvas event listeners for undo/redo and real-time sync
        canvas.on('object:added', function(e) {
            console.log('üîµ Canvas: Object added', e.target);
            addDebugEvent(`Canvas: Object added - ${e.target.type}`);
            saveToUndoStack();
            if (isConnected && socket) {
                console.log('üîµ Emitting add-element event');
                emitCanvasUpdate('add-element', e.target);
            } else {
                console.log('üî¥ Cannot emit: Socket not ready', { isConnected, socket: !!socket });
                addDebugEvent(`Cannot emit add-element: Connected=${isConnected}, Socket=${!!socket}`);
            }
        });
        
        canvas.on('object:modified', function(e) {
            console.log('üîµ Canvas: Object modified', e.target);
            addDebugEvent(`Canvas: Object modified - ${e.target.type}`);
            saveToUndoStack();
            if (isConnected && socket) {
                console.log('üîµ Emitting modify-element event');
                emitCanvasUpdate('modify-element', e.target);
            } else {
                console.log('üî¥ Cannot emit: Socket not ready', { isConnected, socket: !!socket });
                addDebugEvent(`Cannot emit modify-element: Connected=${isConnected}, Socket=${!!socket}`);
            }
        });
        
        canvas.on('object:removed', function(e) {
            console.log('üîµ Canvas: Object removed', e.target);
            addDebugEvent(`Canvas: Object removed - ${e.target.type}`);
            saveToUndoStack();
            if (isConnected && socket) {
                console.log('üîµ Emitting delete-element event');
                emitCanvasUpdate('delete-element', e.target);
            } else {
                console.log('üî¥ Cannot emit: Socket not ready', { isConnected, socket: !!socket });
                addDebugEvent(`Cannot emit delete-element: Connected=${isConnected}, Socket=${!!socket}`);
            }
        });

        // Drawing events for real-time sync
        canvas.on('path:created', function(e) {
            console.log('üîµ Canvas: Path created', e.path);
            addDebugEvent(`Canvas: Path created - ${e.path.type}`);
            if (isConnected && socket) {
                console.log('üîµ Emitting draw event from path:created');
                emitCanvasUpdate('draw', e.path);
            } else {
                console.log('üî¥ Cannot emit: Socket not ready', { isConnected, socket: !!socket });
                addDebugEvent(`Cannot emit draw from path:created: Connected=${isConnected}, Socket=${!!socket}`);
            }
        });

        // Alternative drawing event handling for better compatibility
        canvas.on('mouse:up', function(e) {
            console.log('üîµ Canvas: Mouse up event', { isDrawingMode: canvas.isDrawingMode, isConnected, hasSocket: !!socket });
            addDebugEvent(`Canvas: Mouse up - Drawing mode: ${canvas.isDrawingMode}`);
            
            if (isConnected && socket) {
                // Capture the last drawn path regardless of drawing mode
                const objects = canvas.getObjects();
                const lastObject = objects[objects.length - 1];
                console.log('üîµ Last object after mouse up:', lastObject);
                
                if (lastObject && lastObject.type === 'path' && !lastObject.isRemote) {
                    console.log('üîµ Emitting draw event from mouse:up');
                    addDebugEvent(`Emitting draw from mouse:up - Path object found`);
                    emitCanvasUpdate('draw', lastObject);
                } else if (lastObject && lastObject.type === 'path' && lastObject.isRemote) {
                    console.log('üîµ Remote path object - not emitting');
                    addDebugEvent('Remote path object - not emitting');
                } else {
                    console.log('üî¥ No local path object found after mouse up');
                    addDebugEvent(`No local path object found after mouse up - Last object: ${lastObject ? lastObject.type : 'none'}`);
                }
            } else {
                console.log('üî¥ Mouse up conditions not met', { 
                    isConnected, 
                    hasSocket: !!socket
                });
                addDebugEvent(`Mouse up conditions not met: Connected=${isConnected}, Socket=${!!socket}`);
            }
        });

        // Enhanced drawing event handling for real-time sync
        canvas.on('after:render', function() {
            if (isConnected && socket) {
                // Check if there are new drawing objects regardless of drawing mode
                const objects = canvas.getObjects();
                const drawingObjects = objects.filter(obj => obj.type === 'path' && !obj.isRemote && !obj.synced);
                
                if (drawingObjects.length > 0) {
                    const lastDrawing = drawingObjects[drawingObjects.length - 1];
                    if (lastDrawing) {
                        console.log('üîµ Emitting draw event from after:render');
                        addDebugEvent(`Emitting draw from after:render - New unsynced path`);
                        lastDrawing.synced = true;
                        emitCanvasUpdate('draw', lastDrawing);
                    }
                }
            }
        });

        // Additional drawing event handlers for comprehensive coverage
        canvas.on('mouse:down', function(e) {
            console.log('üîµ Canvas: Mouse down event', { 
                isDrawingMode: canvas.isDrawingMode, 
                currentTool, 
                isConnected, 
                hasSocket: !!socket 
            });
            addDebugEvent(`Canvas: Mouse down - Tool: ${currentTool}, Drawing mode: ${canvas.isDrawingMode}`);
        });

        canvas.on('mouse:move', function(e) {
            if (canvas.isDrawingMode && isConnected && socket) {
                console.log('üîµ Canvas: Mouse move while drawing');
                addDebugEvent('Canvas: Mouse move while drawing');
            }
        });

        // Monitor drawing brush changes
        canvas.on('brush:created', function(e) {
            console.log('üîµ Canvas: Brush created', e);
            addDebugEvent('Canvas: Brush created');
        });

        canvas.on('brush:modified', function(e) {
            console.log('üîµ Canvas: Brush modified', e);
            addDebugEvent('Canvas: Brush modified');
        });

        // Direct drawing event handler for real-time sync
        canvas.on('path:created', function(e) {
            console.log('üîµ Canvas: Path created event', e);
            addDebugEvent('Path created event fired');
            
            if (isConnected && socket && e.path && !e.path.isRemote) {
                console.log('üîµ Emitting draw event from path:created');
                addDebugEvent('Emitting draw from path:created');
                
                // Mark as synced immediately to prevent duplicate emissions
                e.path.synced = true;
                emitCanvasUpdate('draw', e.path);
            } else {
                console.log('üî¥ Cannot emit from path:created:', { 
                    isConnected, 
                    hasSocket: !!socket, 
                    hasPath: !!e.path,
                    isRemote: e.path ? e.path.isRemote : 'no path'
                });
                addDebugEvent(`Cannot emit from path:created: Connected=${isConnected}, Socket=${!!socket}, Path=${!!e.path}`);
            }
        });

        // Enhanced drawing event handler with comprehensive logging
        canvas.on('object:added', function(e) {
            console.log('üîµ Canvas: Object added event', e.target);
            addDebugEvent(`Object added: ${e.target.type}`);
            
            // Check if this is a new drawing path
            if (e.target && e.target.type === 'path' && !e.target.isRemote && !e.target.synced) {
                console.log('üîµ New drawing path detected, marking for sync');
                addDebugEvent('New drawing path detected for sync');
                
                // Mark for sync and emit
                e.target.synced = true;
                emitCanvasUpdate('draw', e.target);
            }
        });

        // Monitor free drawing brush events
        if (canvas.freeDrawingBrush) {
            canvas.freeDrawingBrush.on('path:created', function(e) {
                console.log('üîµ FreeDrawingBrush: Path created', e);
                addDebugEvent('FreeDrawingBrush path created');
                
                if (isConnected && socket && e.path && !e.path.isRemote) {
                    console.log('üîµ Emitting draw event from FreeDrawingBrush');
                    addDebugEvent('Emitting draw from FreeDrawingBrush');
                    
                    // Mark as synced immediately
                    e.path.synced = true;
                    emitCanvasUpdate('draw', e.path);
                }
            });
        }
    </script>
</body>
</html> 